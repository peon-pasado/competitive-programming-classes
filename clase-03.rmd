---
title: "number theory"
author: "Miguel Miní"
date: "1/16/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Number Theory

En esta sección veremos herramientas de teoría de números indispensables,
muchos de los problemas en programación competitiva necesitan el entendimiento
de estos problemas:

## Relación de congruencia

Para un entero positivo $n$, dos números $a$ y $b$ se dicen congruentes
módulo $n$. Si la diferencia $a - b$ es un entero múltiplo de $n$. Y es 
considerada como:

$$a \equiv b ~(mod ~n)$$

### propiedades:

- Reflexibidad: $a \equiv a ~(mod ~n)$
- Simetría: $a \equiv b ~(mod ~n)$ si $b \equiv a ~(mod ~n)$, para todo a, b, n.
- Transitividad: si $a \equiv b ~(mod ~n)$ y $b \equiv c ~(mod ~n)$, entonces $a \equiv c ~(mod ~n)$

Si $a = p n + r$ y $b = q n + r$ [(1)](https://en.wikipedia.org/wiki/Division_algorithm), 
entonces $a \sim r$, $b \sim r$ y $a \sim b$ al mínimo $r$ positivo se le denomina el
característico de la clase y denotamos $$[a] = [b] = r$$.

## Aritmética modular

- Las relaciones de congruencia funcionan bien bajo operaciones aritméticas, esto quiere
decir que $[a] + [b] = [a+b]$ y $[a] . [b] = [a . b]$.

nota: esto quiere decir que si yo hago operaciones modulares sobre $n$, entonces
yo puedo realizarlas en cualquier orden, además, si la respuesta es menor a n, la
respuesta final será igual aplicando aritmética usual o aritmética modular. 

## Máximo Común Divisor

Dados a y b, el máximo común divisor es el máximo entero $g$ menor a min($a$, $b$), 
tal que $a \equiv 0 ~(mod ~g)$ y $b \equiv 0 ~(mod ~g)$. 

Si $d$ divide a $g$, además, se cumple que $g = d  ~gcd(a / d, b / d)$. 

## Exponenciación Rápida:

Este algoritmo solo necesita que $b$ sea un entero en base 2, y que se
aplique una función asociativa sobre $a$, $b$ veces. Esto nos deja la 
puerta abierta para poder hacer $a b$, $a^b$, $A^b$ donde $A$ puede
ser una matriz.

### descripción:

En este caso nosotros estamos implementando $a ^ b ~(mod ~m)$, para 
ello podemos pensar $b$ como una secuencia de bits: $b_k, b_{k-1}, \dots, b0$,
entonces por propiedad de la exponenciación: $a ^ b = (a^{b_k 2^k}) (a^{b_{k-1} 2^{k-1}})\dots(a^{b_0 2^0})$, esto nos dice que podemos hallar la secuencia $a^{2^0}, a^{2^1}, \dots, a^{2^k}$ y elegir cual conviene respecto a la secuencia de $b$.

```cpp
int ex(int a, int b, int m) {
  int r = 1;
  while (b > 0) {
    if (b&1) r = r * 1ll * a % m; //aca aplicas la funcion
    a = a * 1ll * a % m; //aca aplicas la funcion
    b >>= 1;
  }
  return r;
} 
```

## Algoritmo de Euclides:

Euclides describe este algoritmo en sus Elementos, c. 300 BC, este es basado 
en usar recursivamente el algoritmo de la división. 

### descripción:

hacemos $x_0 = a$, $x_1 = b$, entonces en cada paso $i$, tenemos:

$x_{i-1} = q_i x_i + x_{i+1}$ para $0 \le i \le k$

así hasta que $x_k = 0$, en ese caso $x_{k-1}$ es la respueta a nuestro problema.

### propiedades del Algoritmo de Euclides:

para $0 < i \le k$, $q_i >= 1$ luego $x_{i-1} >= x_i + x_{i+1}$ y $x_i > x_{i+1}$
con lo cuál $x_{i-1} > 2 * x_{i+1}$, por tanto, la secuencia $x_i$ decrece para
elementos consecutivos con la misma paridad en forma exponencial. 

Por otro lado, si $d$ divide a $x_{i-1}$ y $x_i$, entonces $d$ divide a $x_{i+1}$,
por tanto, el máximo común divisor divide a $x_{k-1}$. En el mismo sentido, todos
los $x_i$ con $0 \le i < k-1$ son divisibles por $x_{k-1}$. Concluimos $x_{k-1}$ es
el máximo común divisor de $a$ y $b$.

```cpp
int gcd(int a, int b) {
  if (b == 0) return a;
  return gcd(b, a%b);
}

int gcd(int a, int b) {
  while (b != 0) {
    int r = a % b;
    a = b;
    b = r;
  }
  return a;
}
```

### Identidad de Bézout

La Identidad de Bézout [(2)](https://brilliant.org/wiki/bezouts-identity/) nos dice que dados $a$ y $b$ enteros positivos, existen
$x$ e $y$ que cumplen:

$$a x + by = gcd(a, b)$$

No probaremos que la identidad se cumple, pero esta sale facilmente manipulando 
el algoritmo de $Euclides$

Sin embargo, la identidad junto con el algoritmo de euclides nos dicen como hallar
dichos $x$ e $y$.

$$ax + by = gcd(a, b)$$
$$bx + (a\%b)y = gcd(b, a\%b)$$

La última ecuación se puede reescribir como:

$$bx + (a - (a//b) b)y = gcd(b, a\%b)$$
Pero además sabemos que gcd($a$, $b$) $=$ gcd($b$, $a\%b$). Si reacomodamos 
la segunda ecuación modificada tenemos:

$$ay + b(x - (a//b)y) = gcd(a, b)$$

Con lo cual tenemos una función recursiva para $x$ e $y$:

$$(x_i, y_i) = (y_{i+1}, x_{i+1} - (a//b)y_{i+1})$$

### implementación:

```cpp
int bezout(int a, int b, int& x_0, int& y_0) {
  if (b == 0) { //solucion base a 1 + b 0 = a
    x_0 = 1;
    y_0 = 0;
    return a;
  }  
  int x_1, y_1;
  int g = bezout(b, a%b, x_1, y_1);
  x_0 = y_1;
  y_0 = x_1 - (a/b) * y_1;
  return g;
}
```

## Pequeño Teorema de Fermat


## Teorema de Euler


ver teorema extendido de Euler.

## Teorema Chino del Resto


## Divisores y Números Primos:

### Divisores:

Para hallar los divisores de un número n, tenemos varios enfoques: 

### criba de eratostenes


### extención de la criba


### Hallando divisores más rapido