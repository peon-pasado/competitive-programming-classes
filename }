---
title: "Clase 08: Recursión"
author: "Leonidas"
date: "30-01-2020"
output: html_document
---

```{r setup, include=FALSE}
htmltools::tagList(rmarkdown::html_dependency_font_awesome())
```
<div class="topic">Nociones básicas</div>

Imagina que tienes una función $f$ que resuelve un problema de esta manera:

* Cuando estas en un estado con una propiedad específica sabemos como resolver
  el problema sin depender de otros estados.

* Cuando no estamos en un estado con la propiedad específica sabemos como
  resolver el problema usando otras instancia de $f$.

Por ejemplo:

$$f(n) = 1 * 2 * 3 * \dots * n$$

Queremos calcular $f(n)$ de una manera recursiva. Entonces necesitamos:

* Identificar un estado con una propiedad específica que podamos resolver
  fácilmente.

  Si $n = 0 \to f(0) = 1$.

* Identifica como resolve $f(n)$ usando diferentes estados de $f$ (estados más
  'cercanos' a los estados con la propiedad específica).

$$f(n) = \underbrace{1 * 2 * 3 * \dots * (n - 1)}_{\text{f(n - 1)}} * n$$
$$f(n) = n * f(n - 1)$$


Entonces, básicamente estamos diciendo que si $n = 0$ sabemos como resolver el
problema, sino si sabemos la respuesta de $f(n - 1)$ podemos resolver $f(n)$.

En código esto es así:

```c++
ll f (int n) {
  if (n == 0) return 1;
  return n * f(n - 1);
}
```

Lo que es agradable sobre recursión es que podemos llegar a las soluciones
pensando de manera recursiva. Pensar de esta manera puede facilitar una gran
variedad de problemas. Para ello puedes decir:

Sea $f$ la función que resuelva el problema que estoy intentando resolver.
Entonces, podemos decir: No tengo idea como resolver $f(state)$, pero si de
alguna manera tuviera el resultado de $f(state'), f(state''), f(state'''),
\dots$ entonces yo podría resolver $f(state)$ y yo se como resolver el problema
en casos específicos a los que siempre termino llegando.

Así, en código, soluciones recursivas suelen tener esta forma:

```vw
T f(state):
  if (state tiene alguna propiedad en específico):
    resuelve el problema para este estado y retorna algo
  else:
    obten la respuesta de f(state'), f(state''), f(state'''), ...
    y usa estos resultados para calcular f(state) y retorna algo
```

<div class="topic">Las torres de Hanoi</div>

Veamos como podemos resolver un problema aparentemente dificil usando
recursión.

![](./images/class-08/Hanoi.jpeg)

La imagen fue extraída de [Wikipedia](https://en.wikipedia.org/wiki/Tower_of_Hanoi#/media/File:Tower_of_Hanoi.jpeg).

**Problema:** Tienes 3 postes fijos y una pila de $n$ discos en un poste. Cada
disco tiene diferente diámetro, los discos están en orden puestos uno encima de
otro, el más gran en el fondo y el más pequeño en la cima. Queremos mover todos
los discos de un poste a otro. Solo podemos mover el disco que está primero en
un poste a otro poste que este vacío o uno done el diámetro del disco que esta
en su cima es mayor del diámetro del disco que estamos moviendo. 

Digamos que tenemos la función $f$ tal que $f(source, target, pivot, n)$ mueve
los $n$ discos que estan en el poste `source` al poste `target`. Entoces,
podemos decir:

Si yo quiero mover los $n$ discos del poste `source` al poste `target`, primero
yo necesito mover $n - 1$ discos de `source` a `pivot`, después moveré el
último disco de `source` a `target`. Tras ese movimiento moveré los $n - 1$
discos de `pivot` a `target` y así ya tendremos el problema resuelto. Además,
si solo hay un disco en un poste podemos moverlo directamente a `target`. De
este modo, podemos escribir $f$ de esta manera:

```bw
void f(source, target, pivot, n):
  if n == 1:
    mueve el disco de source a target
    return
  # mueve los primeros n - 1 discos de source a pivot
  f(source, pivot, target, n - 1)
  # mueve el último disco de source a target  
  f(source, target, pivot, 1)
  # mueve los n - 1 discos de pivot a target
  f(pivot, target, source, n - 1)
```

Y eso es todo, esto resuelve el problema.

<div class="topic">Ejercicios</div>

Implementa soluciones recursivas para los siguientes ejercicios:

* $fib(n)$


  <!-- begin code -->
  <div class="collapsed code-title" type="button" data-toggle="collapse" data-target="#codeProblemfib" aria-expanded="false" aria-controls="collapseTwo">
  <!-- title -->
  <i class="fas fa-caret-right"></i> <p class="title">Code</p>
  </div>
  <div id="codeProblemfib" class="collapse">

```c++
// TO DO
```

  </div>
  <!-- ends code -->




* Suma de dígitos de un número n




* $C(n, k)$


* Determinante de una matrix (**Challenge**)



Lecturas recomendadas:

* Concrete Mathematics - Knuth. Chapter 1
* [GPC-UNI Clase 9](https://nbviewer.jupyter.org/github/GPC-UNI/Programacion-Competitiva/blob/master/uni-no-fiis/clase-09/clase-09.ipynb)
* [Competitive Programmer’s Handbook, chapters 5, 8 y 21](https://jadi.net/wp-content/uploads/2017/07/competetive-programmers-handbook.pdf)
* [Learn Data Structures and Algorithms, section Basic Recursion](https://www.codechef.com/certification/data-structures-and-algorithms/prepare)


<div class=topic>Contest</div>

El contest lo puedes encontrar [aquí](https://vjudge.net/contest/354437).
