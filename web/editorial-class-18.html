<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="GPC-UNI Resto del Mundo" />


<title>Editorial - Contest Programación Dinámica</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/yeti.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/textmate.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>


<link rel="stylesheet" href="style.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 45px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 50px;
  margin-top: -50px;
}
.section h2 {
  padding-top: 50px;
  margin-top: -50px;
}
.section h3 {
  padding-top: 50px;
  margin-top: -50px;
}
.section h4 {
  padding-top: 50px;
  margin-top: -50px;
}
.section h5 {
  padding-top: 50px;
  margin-top: -50px;
}
.section h6 {
  padding-top: 50px;
  margin-top: -50px;
}
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #ffffff;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->




</head>

<body>


<div class="container-fluid main-container">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">GPC-UNI Resto del mundo</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="schedule.html">Cronograma</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Clases
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="class-01.html">Introducción</a>
    </li>
    <li>
      <a href="class-02.html">Complejidades + STL</a>
    </li>
    <li>
      <a href="class-03.html">Contest 1</a>
    </li>
    <li>
      <a href="class-04.html">Teoría de números</a>
    </li>
    <li>
      <a href="class-05.html">Fuerza bruta I</a>
    </li>
    <li>
      <a href="class-06.html">Fuerza bruta II</a>
    </li>
    <li>
      <a href="class-07.html">Contest 2</a>
    </li>
    <li>
      <a href="class-08.html">Recursión</a>
    </li>
    <li>
      <a href="class-09.html">Backtracking I</a>
    </li>
    <li>
      <a href="class-10.html">Recapitulacion I</a>
    </li>
    <li>
      <a href="class-11.html">Contest UNI-UTEC I</a>
    </li>
    <li>
      <a href="class-12.html">Backtracking II</a>
    </li>
    <li>
      <a href="class-13.html">Backtracking II</a>
    </li>
    <li>
      <a href="class-14.html">Bitmask</a>
    </li>
    <li>
      <a href="class-15.html">Introducción a Greedy</a>
    </li>
    <li>
      <a href="class-16.html">7 Greedy Problems</a>
    </li>
    <li>
      <a href="class-17.html">Meet in the middle</a>
    </li>
    <li>
      <a href="class-18.html">Dynamic Programming</a>
    </li>
    <li>
      <a href="class-19.html">Grafos</a>
    </li>
    <li>
      <a href="class-20.html">Divide and Conquer</a>
    </li>
    <li>
      <a href="class-21.html">DP Classics</a>
    </li>
    <li>
      <a href="class-22.html">Max Flow Introduction</a>
    </li>
    <li>
      <a href="class-23.html">Max Flow Algorithm</a>
    </li>
    <li>
      <a href="class-24.html">Sparse Table</a>
    </li>
    <li>
      <a href="class-25.html">Binary Indexed Tree</a>
    </li>
    <li>
      <a href="class-26.html">Introducción a Strings - I</a>
    </li>
    <li>
      <a href="class-27.html">Introducción a Strings - II</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    TC Argentina 2020
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="TCAC1-EditorialI.html">Editorial Contest 1 - Inicial</a>
    </li>
    <li>
      <a href="TCAC1-EditorialA.html">Editorial Contest 1 - Avanzado</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="daily-problem.html">Problema del día</a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">



<h1 class="title toc-ignore">Editorial - Contest Programación Dinámica</h1>
<h4 class="author">GPC-UNI Resto del Mundo</h4>
<h4 class="date">25-05-2020</h4>

</div>


<div id="a.-make-product-equal-one" class="section level3">
<h3><a href="https://vjudge.net/contest/374440#problem/A">A. Make Product Equal One</a></h3>
<p>Para resolver este problema debemos notar que la solución óptima es una combinación de 1s y -1s, y dado que el producto debe ser 1, tendremos una cantidad par de -1s.</p>
<p>Con la observación anterior podemos plantear una recursión que considere la paridad de la cantidad de -1s, y la solución final será una con paridad = 0.</p>
<p>Si <span class="math inline">\(memo_{i, r}\)</span> es la solución óptima para los elementos en el rango <span class="math inline">\([1, i]\)</span> para que el resultado tenga una cantidad de -1s <span class="math inline">\(x\)</span> con <span class="math inline">\(x \equiv r \mod 2\)</span>, entonces podemos plantear dos posibilidades:</p>
<ol style="list-style-type: decimal">
<li><p><span class="math inline">\(a_{i}\)</span> es convertido a <span class="math inline">\(1\)</span> con un costo de <span class="math inline">\(|a_{i} - 1|\)</span>, lo que significa que la cantidad de <span class="math inline">\(-1\)</span> no ha variado.</p></li>
<li><p><span class="math inline">\(a_{i}\)</span> es convertido a <span class="math inline">\(-1\)</span> con un costo de <span class="math inline">\(|a_{i} + 1|\)</span>, lo que significa que la cantidad de <span class="math inline">\(-1\)</span> ha cambiado, lo cual puede ser representado como modificar el bit <span class="math inline">\(r\)</span> de 1 a 0 o de 0 a 1 usando Bitwise XOR.</p></li>
</ol>
<p><span class="math display">\[ memo_{i, r} = \min{\{|a_{i} - 1| + memo_{i-1, r}, |a_{i} + 1| + memo_{i-1, r \oplus 1}\}} \]</span></p>
<p>Donde <span class="math inline">\(\oplus\)</span> es la función XOR.</p>
<p>Complejidad: <span class="math inline">\(O(n)\)</span>.</p>
<!-- begin code -->
<div class="collapsed code-title" type="button" data-toggle="collapse" data-target="#codeExample1" aria-expanded="false" aria-controls="collapseTwo">
<!-- title -->
<i class="fas fa-caret-right"></i>
<p class="title">
Code
</p>
</div>
<div id="codeExample1" class="collapse">
<pre class="cpp"><code>#include&lt;bits/stdc++.h&gt;
using namespace::std;

const int N = 100000+5;
const long long inf = 1LL&lt;&lt;50;

int n;
int a[N];
long long memo[N][3];

int main(){
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=1; i&lt;=n; i++){
        scanf(&quot;%d&quot;, &amp;a[i]);
    }
    memo[0][0] = 0; // No elements, Q(-1) = 0
    memo[0][1] = inf; // No elements, Q(-1) = 1 mod 2 is impossible
    for(int i=1; i&lt;=n; i++){
        for(int r = 0; r &lt; 2; r++){
            memo[i][r] = min(abs(a[i] - 1) + memo[i-1][r], abs(a[i] + 1) + memo[i-1][r^1]);
        }
    }
    printf(&quot;%lld\n&quot;,memo[n][0]);
    return 0;
}</code></pre>
</div>
<!-- ends code -->
</div>
<div id="b.-odd-sum" class="section level3">
<h3><a href="https://vjudge.net/contest/374440#problem/B">B. Odd sum</a></h3>
<p>Para resolver este problema podemos plantear una función que nos dé la máxima suma de entre todas las subsecuencias que use los elementos del rango <span class="math inline">\([1,i]\)</span> y que esta suma tenga paridad <span class="math inline">\(r\)</span>. (Sí, es un planteamiento casi igual que el problema anterior)</p>
<p>De esta forma, tenemos nuestra recursión <span class="math inline">\(memo_{i, r}\)</span>:</p>
<p><span class="math display">\[ memo_{i, r} = \max{\{memo_{i-1, r}, memo_{i-1, r \oplus (a_{i} \mod 2)} + a_{i}\}} \]</span></p>
<p>Notemos que el resultado de <span class="math inline">\(r \oplus (a_{i} \mod 2)\)</span> tiene la paridad necesaria para que al sumar <span class="math inline">\(a_{i}\)</span> se obtenga <span class="math inline">\(r\)</span> como paridad final.</p>
<p>La respuesta será <span class="math inline">\(memo_{n, 1}\)</span>.</p>
<p>Complejidad: <span class="math inline">\(O(n)\)</span>.</p>
<!-- begin code -->
<div class="collapsed code-title" type="button" data-toggle="collapse" data-target="#codeExample2" aria-expanded="false" aria-controls="collapseTwo">
<!-- title -->
<i class="fas fa-caret-right"></i>
<p class="title">
Code
</p>
</div>
<div id="codeExample2" class="collapse">
<pre class="cpp"><code>#include&lt;bits/stdc++.h&gt;
using namespace::std;

const int N = 100000+5;
const int inf = 1LL&lt;&lt;29;

int n;
int a[N];
int memo[N][3];

int main(){
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=1; i&lt;=n; i++){
        scanf(&quot;%d&quot;, &amp;a[i]);
    }
    memo[0][0] = 0; // No elements, sum = 0
    memo[0][1] = -inf; // No elements, sum = 1 mod 2 is not possible
    for(int i=1; i&lt;=n; i++){
        for(int r = 0; r &lt; 2; r++){
            int par = abs(a[i]) &amp; 1;
            memo[i][r] = max(memo[i-1][r], memo[i-1][r^par] + a[i]);
        }
    }
    printf(&quot;%d\n&quot;, memo[n][1]);
    return 0;
}</code></pre>
</div>
<!-- ends code -->
</div>
<div id="c.-longest-regular-bracket-sequence" class="section level3">
<h3><a href="https://vjudge.net/contest/374440#problem/C">C. Longest Regular Bracket Sequence</a></h3>
<p>Para resolver este problema, debíamos analizar la naturaleza de una expresión de paréntesis balanceada:</p>
<ol style="list-style-type: decimal">
<li><p>La cadena vacía es balanceada</p></li>
<li><p>Si <span class="math inline">\(A\)</span> es balanceada, entonces <span class="math inline">\((A)\)</span> es balanceada</p></li>
<li><p>Si <span class="math inline">\(A\)</span> y <span class="math inline">\(B\)</span> son balanceadas, entonces <span class="math inline">\(AB\)</span> es balanceada</p></li>
</ol>
<p>Nos vamos a basar en la 3era propiedad:</p>
<p>Si podemos encontrar la primera expresión balanceada que termina en cada posición y además mantenemos un arreglo <span class="math inline">\(memo_{i}\)</span> que guarde la máxima longitud de todas las expresiones balanceadas que terminan en la posición <span class="math inline">\(i\)</span>, la respuesta para <span class="math inline">\(i\)</span> sería obtenida por:</p>
<p><span class="math display">\[ memo_{i} = i - x + 1 + memo_{x-1} \]</span></p>
<p>Donde <span class="math inline">\(x\)</span> es la posición en la que empieza la primera expresión balanceada que termina en <span class="math inline">\(i\)</span> (en caso haya una).</p>
<p>Podemos obtener <span class="math inline">\(x\)</span> para cada <span class="math inline">\(i\)</span> realizando una simulación con una pila, en la que almacenaremos las posiciones de los <span class="math inline">\((\)</span> para compararlos con los <span class="math inline">\()\)</span>.</p>
<p>Complejidad: <span class="math inline">\(O(n)\)</span>.</p>
<!-- begin code -->
<div class="collapsed code-title" type="button" data-toggle="collapse" data-target="#codeExample3" aria-expanded="false" aria-controls="collapseTwo">
<!-- title -->
<i class="fas fa-caret-right"></i>
<p class="title">
Code
</p>
</div>
<div id="codeExample3" class="collapse">
<pre class="cpp"><code>#include&lt;bits/stdc++.h&gt;
using namespace::std;

const int N = 1000000+5;

int n;
char s[N];
int memo[N];

int main(){
    scanf(&quot;%s&quot;,s + 1);
    n = strlen(s + 1);
    int maxi = 0;
    int frec = 1;
    stack&lt;int&gt; S;
    for(int i = 1; i &lt;= n; i++){
        if(s[i] == &#39;(&#39;){
            S.emplace(i);
        }
        else{
            if(!S.empty()){
                int x = S.top();
                S.pop();
                memo[i] = memo[x-1] + i - x + 1;
            }
        }
        if(memo[i] &gt; maxi){
            maxi = memo[i];
            frec = 1;
        }
        else if(memo[i] &gt; 0 and memo[i] == maxi){
            frec += 1;
        }
    }
    printf(&quot;%d %d\n&quot;, maxi, frec);
    return 0;
}</code></pre>
</div>
<!-- ends code -->
</div>
<div id="d.-antimatter" class="section level3">
<h3><a href="https://vjudge.net/contest/374440#problem/D">D. Antimatter</a></h3>
<p>Para resolver este problema, deberemos considerar particionar el conjunto de subarreglos en subconjuntos definidos por la posición del extremo derecho <span class="math inline">\(r\)</span>. De esta forma, tendremos <span class="math inline">\(n\)</span> subconjuntos disjuntos, por lo que podremos simplemente sumar sus tamaños para obtener la respuesta final.</p>
<p>Definiremos una recursión <span class="math inline">\(memo_{i, suma}\)</span> como la cantidad de subarreglos que terminen en <span class="math inline">\(i\)</span> tales que tengan suma <span class="math inline">\(suma\)</span>:</p>
<p><span class="math display">\[ memo_{i, suma} = memo_{i - 1, suma - a_{i}} + memo_{i - 1, suma + a_{i}} \]</span></p>
<p>Donde el primer término significa que hemos usado el <span class="math inline">\(i\)</span>-ésimo elemento para crear materia y el segundo significa que creamos antimateria. Sin embargo, esta recursión por sí misma necesita de algo más; ya que, si procesamos la inicialización de <span class="math inline">\(memo_{0,0} = 1\)</span> únicamente, estaremos contando los posibles resultados usando <strong>todos</strong> los elementos del rango <span class="math inline">\([1, i]\)</span>.</p>
<p>Para solucionar el problema anterior, agregaremos <span class="math inline">\(1\)</span> a cada <span class="math inline">\(memo_{i, 0}\)</span> al procesar los resultados, ya que este valor significará el tomar como inicio el elemento de la posición <span class="math inline">\(i+1\)</span>. Ya que estaríamos agregando <span class="math inline">\(1\)</span> a cada <span class="math inline">\(memo_{i, 0}\)</span> y la respuesta final debería ser la suma de <span class="math inline">\(memo_{i, 0}\)</span>, deberemos restarle <span class="math inline">\(n\)</span> al suma final para emparejar esos <span class="math inline">\(1\)</span> agregados.</p>
<p>Podemos implementar esta recursión usando un arreglo y desplazando los resultados negativos lo suficiente para que el mapeo resultante sea no negativo: Sumamos 10000 a todos los posibles valores (ya que la suma de todos los <span class="math inline">\(a_{i}\)</span> es a lo mucho ese valor) y manejaremos los índices del arreglo de manera adecuada.</p>
<p>Complejidad: <span class="math inline">\(O\left(n\cdot\sum\limits_{i=1}^{n}a_{i}\right)\)</span>.</p>
<!-- begin code -->
<div class="collapsed code-title" type="button" data-toggle="collapse" data-target="#codeExample4" aria-expanded="false" aria-controls="collapseTwo">
<!-- title -->
<i class="fas fa-caret-right"></i>
<p class="title">
Code
</p>
</div>
<div id="codeExample4" class="collapse">
<pre class="cpp"><code>#include&lt;bits/stdc++.h&gt;
using namespace::std;

const int N = 1000+5;
const int MAX = 20000+5;
const int OFF = 10000;
const int MOD = 1000000000 + 7;

int n;
int a[N];
int memo[N][MAX];

int main(){
    scanf(&quot;%d&quot;, &amp;n);
    int suma = 0;
    for(int i=1; i&lt;=n; i++){
        scanf(&quot;%d&quot;, &amp;a[i]);
        suma += a[i];
    }
    memo[0][OFF] = 1;
    for(int i=1; i&lt;=n; i++){
        memo[i][OFF] = 1;
        for(int j = -suma; j &lt;= suma; j++){
            if(j - a[i] + OFF &gt;= 0) memo[i][j + OFF] += memo[i-1][j - a[i] + OFF];
            if(j + a[i] + OFF &lt; MAX) memo[i][j + OFF] += memo[i-1][j + a[i] + OFF];
            if(memo[i][j + OFF] &gt;= MOD) memo[i][j + OFF] -= MOD;
        }
    }
    int ans = -n;
    for(int i=1; i&lt;=n; i++){
        ans += memo[i][OFF];
        if(ans &gt;= MOD) ans -= MOD;
    }
    printf(&quot;%d\n&quot;,ans);
    return 0;
}</code></pre>
</div>
<!-- ends code -->
</div>
<div id="e.-flags" class="section level3">
<h3><a href="https://vjudge.net/contest/374440#problem/E">E. Flags</a></h3>
<p>Para resolver este problema debemos notar que los únicos colores con los que puede terminar la bandera son el rojo y el blanco, entonces definiremos la recursión:</p>
<ol style="list-style-type: decimal">
<li><p><span class="math inline">\(memo_{i, 0}\)</span> será la cantidad de banderas de longitud <span class="math inline">\(i\)</span> que terminan en color rojo</p></li>
<li><p><span class="math inline">\(memo_{i, 1}\)</span> será la cantidad de banderas de longitud <span class="math inline">\(i\)</span> que terminan en color blanco</p></li>
</ol>
<p>De forma que nuestra respuesta deseada será <span class="math inline">\(memo_{n, 0} + memo_{n, 1}\)</span>.</p>
<p>Ahora, consideremos cómo será la recursión para calcular <span class="math inline">\(memo_{i, 0}\)</span>:</p>
<p><span class="math display">\[ memo_{i, 0} = memo_{i - 1, 1} + memo_{i - 2, 1} \]</span></p>
<p>Siendo el primer término debido a la primera regla y el segundo es equivalente a colocar una franja de color azul, la cual debe estar entre una de blanco y una de rojo, por lo que al fijar el vecino derecho como rojo, el vecino izquierdo (<span class="math inline">\(i-2\)</span>) deberá ser blanco.</p>
<p>Notemos que se da de manera análoga para el color blanco:</p>
<p><span class="math display">\[ memo_{i, 1} = memo_{i - 1, 0} + memo_{i - 2, 0} \]</span></p>
<p>Y <span class="math inline">\(memo_{1, 0} = memo_{1, 1} = 1\)</span>, <span class="math inline">\(memo_{1, 0} = memo_{1, 1} = 1\)</span>, por lo que podemos calcular los resultados sin problemas.</p>
<p>Una observación extra es notar que la función suma <span class="math inline">\(s_{i} = memo_{i, 0} + memo_{i, 1}\)</span> es una función como la serie de Fibonacci, ya que:</p>
<p><span class="math display">\[ s_{i} = memo_{i, 0} + memo_{i, 1} = (memo_{i - 1, 1} + memo_{i - 2, 1}) + (memo_{i - 1, 0} + memo_{i - 1, 0}) \]</span></p>
<p><span class="math display">\[ s_{i} = (memo_{i - 1, 0} + memo_{i - 1, 1}) + (memo_{i - 2, 0} + memo_{i - 2, 1}) = s_{i - 1} + s_{i - 2} \]</span></p>
<p>Con <span class="math inline">\(s_{1} = s_{2} = 2\)</span>.</p>
<p>Complejidad: <span class="math inline">\(O(n)\)</span>.</p>
<!-- begin code -->
<div class="collapsed code-title" type="button" data-toggle="collapse" data-target="#codeExample5" aria-expanded="false" aria-controls="collapseTwo">
<!-- title -->
<i class="fas fa-caret-right"></i>
<p class="title">
Code
</p>
</div>
<div id="codeExample5" class="collapse">
<pre class="cpp"><code>#include&lt;bits/stdc++.h&gt;
using namespace::std;

const int N = 50;

int n;
long long s[N];

int main(){
    scanf(&quot;%d&quot;, &amp;n);
    s[1] = s[2] = 2;
    for(int i=3; i&lt;=n; i++) s[i] = s[i-1] + s[i-2];
    printf(&quot;%lld\n&quot;, s[n]);
    return 0;
}</code></pre>
</div>
<!-- ends code -->
</div>
<div id="f.-k-based-numbers" class="section level3">
<h3><a href="https://vjudge.net/contest/374440#problem/F">F. K-based Numbers</a></h3>
<p>Para resolver este problema debemos notar que solamente importan los dígitos que son 0 y los que no son 0, siendo este último conjunto de elementos indistinguibles. De esta forma, podemos plantear la siguiente recursión:</p>
<ol style="list-style-type: decimal">
<li><p><span class="math inline">\(memo_{i, 0}\)</span>: Cantidad de números de longitud <span class="math inline">\(i\)</span> tales que terminan en <span class="math inline">\(0\)</span>.</p></li>
<li><p><span class="math inline">\(memo_{i, 1}\)</span>: Cantidad de números de longitud <span class="math inline">\(i\)</span> tales que terminan en un dígito diferente a <span class="math inline">\(0\)</span>.</p></li>
</ol>
<p>Notemos que hay <span class="math inline">\((k - 1)\)</span> elementos en el tipo <span class="math inline">\(1\)</span> y solo 1 en el tipo <span class="math inline">\(0\)</span>.</p>
<p>Ahora veamos las recursiones:</p>
<p><span class="math display">\[ memo_{i, 0} = memo_{i - 1, 1} \]</span></p>
<p>Ya que antes del <span class="math inline">\(0\)</span> solo puede ir un dígito diferente a 0.</p>
<p><span class="math display">\[ memo_{i, 1} = (k - 1) (memo_{i - 1, 0} + memo_{i - 1, 1}) \]</span></p>
<p>Ya que no hay restricciones respecto a los dígitos diferentes a <span class="math inline">\(0\)</span> y podemos usar <span class="math inline">\((k-1)\)</span> opciones para esto.</p>
<p>Ahora, ya que <span class="math inline">\(n \geq 2\)</span>, los números de longitud <span class="math inline">\(1\)</span> nos van a servir para la recursión (a pesar de que teóricamente puedan no coincidir con los resultados), dado que necesitamos números de longitud <span class="math inline">\(n\)</span> que no empiecen con <span class="math inline">\(0\)</span>.</p>
<p>Por la condición anterior, definimos los casos base:</p>
<p><span class="math display">\[ memo_{1, 0} = 0 \]</span> <span class="math display">\[ memo_{1, 1} = k-1 \]</span></p>
<p>Para que todo número construido de izquierda a derecha sea válido. Finalmente nuestra respuesta es <span class="math inline">\(memo_{n, 0} + memo_{n, 1}\)</span>.</p>
<p>Complejidad: <span class="math inline">\(O(n)\)</span>.</p>
<!-- begin code -->
<div class="collapsed code-title" type="button" data-toggle="collapse" data-target="#codeExample6" aria-expanded="false" aria-controls="collapseTwo">
<!-- title -->
<i class="fas fa-caret-right"></i>
<p class="title">
Code
</p>
</div>
<div id="codeExample6" class="collapse">
<pre class="cpp"><code>#include&lt;bits/stdc++.h&gt;
using namespace::std;

const int N = 20;

int n;
int k;
long long memo[N][3];

int main(){
    scanf(&quot;%d %d&quot;, &amp;n, &amp;k);
    memo[1][0] = 0;
    memo[1][1] = k-1;
    for(int i=2; i&lt;=n; i++){
        memo[i][0] = memo[i-1][1];
        memo[i][1] = (long long)(k - 1) * (memo[i-1][0] + memo[i-1][1]);
    }
    printf(&quot;%lld\n&quot;, memo[n][0] + memo[n][1]);
    return 0;
}</code></pre>
</div>
<!-- ends code -->
</div>
<div id="g.-square-country" class="section level3">
<h3><a href="https://vjudge.net/contest/374440#problem/G">G. Square Country</a></h3>
<p>Para resolver este problema bastaba definir la recursión <span class="math inline">\(memo_{i}\)</span>, la cual dará el resultado mínimo para un área de <span class="math inline">\(i\)</span>. Según el enunciado, deberemos minimizar la cantidad de cuadrados en la que puede ser particionada <span class="math inline">\(i\)</span>, así que fijaremos el último cuadrado usado, de esta forma:</p>
<p><span class="math display">\[ memo_{i} = \min\limits_{1 \leq x^{2} \leq i}\{1 + memo_{i - x^{2}}\} \]</span></p>
<!-- begin code -->
<div class="collapsed code-title" type="button" data-toggle="collapse" data-target="#codeExample7" aria-expanded="false" aria-controls="collapseTwo">
<!-- title -->
<i class="fas fa-caret-right"></i>
<p class="title">
Code
</p>
</div>
<div id="codeExample7" class="collapse">
<pre class="cpp"><code>#include&lt;bits/stdc++.h&gt;
using namespace::std;

const int N = 60000+5;

int n;
int memo[N];

int main(){
    scanf(&quot;%d&quot;,&amp;n);
    memo[0] = 0;
    for(int i = 1; i &lt;= n; i++){
        memo[i] = n;
        for(int x = 1; x * x &lt;= i; x++){
            memo[i] = min(memo[i], 1 + memo[i - x * x]);
        }
    }
    printf(&quot;%d\n&quot;, memo[n]);
    return 0;
}</code></pre>
</div>
<!-- ends code -->
</div>




</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
