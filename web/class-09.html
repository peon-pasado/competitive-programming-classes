<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Leonidas" />


<title>Clase 09: Backtracking I</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/yeti.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/textmate.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/font-awesome-5.1.0/css/all.css" rel="stylesheet" />
<link href="site_libs/font-awesome-5.1.0/css/v4-shims.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>


<link rel="stylesheet" href="style.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 45px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 50px;
  margin-top: -50px;
}
.section h2 {
  padding-top: 50px;
  margin-top: -50px;
}
.section h3 {
  padding-top: 50px;
  margin-top: -50px;
}
.section h4 {
  padding-top: 50px;
  margin-top: -50px;
}
.section h5 {
  padding-top: 50px;
  margin-top: -50px;
}
.section h6 {
  padding-top: 50px;
  margin-top: -50px;
}
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #ffffff;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->




</head>

<body>


<div class="container-fluid main-container">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">GPC-UNI Resto del mundo</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="schedule.html">Cronograma</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Clases
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="class-01.html">Introducción</a>
    </li>
    <li>
      <a href="class-02.html">Complejidades + STL</a>
    </li>
    <li>
      <a href="class-03.html">Contest 1</a>
    </li>
    <li>
      <a href="class-04.html">Teoría de números</a>
    </li>
    <li>
      <a href="class-05.html">Fuerza bruta I</a>
    </li>
    <li>
      <a href="class-06.html">Fuerza bruta II</a>
    </li>
    <li>
      <a href="class-07.html">Contest 2</a>
    </li>
    <li>
      <a href="class-08.html">Recursión</a>
    </li>
    <li>
      <a href="class-09.html">Backtracking I</a>
    </li>
    <li>
      <a href="class-10.html">Recapitulacion I</a>
    </li>
    <li>
      <a href="class-11.html">Contest UNI-UTEC I</a>
    </li>
    <li>
      <a href="class-12.html">Backtracking II</a>
    </li>
    <li>
      <a href="class-13.html">Backtracking II</a>
    </li>
    <li>
      <a href="class-14.html">Bitmask</a>
    </li>
    <li>
      <a href="class-15.html">Introducción a Greedy</a>
    </li>
    <li>
      <a href="class-16.html">7 Greedy Problems</a>
    </li>
    <li>
      <a href="class-17.html">Meet in the middle</a>
    </li>
    <li>
      <a href="class-18.html">Dynamic Programming</a>
    </li>
    <li>
      <a href="class-19.html">Grafos</a>
    </li>
    <li>
      <a href="class-20.html">Divide and Conquer</a>
    </li>
    <li>
      <a href="class-21.html">DP Classics</a>
    </li>
    <li>
      <a href="class-22.html">Max Flow Introduction</a>
    </li>
    <li>
      <a href="class-23.html">Max Flow Algorithm</a>
    </li>
    <li>
      <a href="class-24.html">Sparse Table</a>
    </li>
    <li>
      <a href="class-25.html">Binary Indexed Tree</a>
    </li>
    <li>
      <a href="class-26.html">Introducción a Strings - I</a>
    </li>
    <li>
      <a href="class-27.html">Introducción a Strings - II</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    TC Argentina 2020
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="TCAC1-EditorialI.html">Editorial Contest 1 - Inicial</a>
    </li>
    <li>
      <a href="TCAC1-EditorialA.html">Editorial Contest 1 - Avanzado</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="daily-problem.html">Problema del día</a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">



<h1 class="title toc-ignore">Clase 09: Backtracking I</h1>
<h4 class="author">Leonidas</h4>
<h4 class="date">04-02-2020</h4>

</div>


<div class="topic">
Conjunto potencia
</div>
<p>El conjunto potencia de un conjunto es el conjunto de todos sus subconjuntos. Por ejemplo:</p>
<p><span class="math display">\[A = \{1, 2, 3\}\]</span> <span class="math display">\[P(A) = \{\emptyset, \{1\},  \{2\},  \{3\},  \{1, 2\},  \{2, 3\},  \{1, 3\}, \{1, 2, 3\} \}\]</span></p>
<p>Donde <span class="math inline">\(P(A)\)</span> representa el conjunto potencia de <span class="math inline">\(A\)</span>. Además, tenemos que <span class="math inline">\(|P(A)| = 2^{|A|}\)</span>.</p>
<p><strong>Extra:</strong> En algunos libros, <span class="math inline">\(P(A)\)</span> es escrito como <span class="math inline">\(2^{A}\)</span> (e.g <a href="https://www.amazon.com/-/es/Jiri-Matousek/dp/0198570422">Motousek - Invitation to Discrete Mathematics</a>).</p>
<p>Podemos generar el conjunto potencia de un conjunto usando recursión, pero antes de eso recordemos las distintas formas de pasar argumentos a una función en C++.</p>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
     
using namespace std;
     
// Pasamos una referencia a &#39;arr&#39; en O(1)
// PUEDES leer de &#39;arr&#39;, pero NO PUEDES modificarlo
void f1 (const vector &lt;int&gt;&amp; arr) {

}

// Pasamos una referencia a &#39;arr&#39; en O(1)
// PUEDES leer de &#39;arr&#39; y PUEDES modificarlo
void f2 (vector &lt;int&gt;&amp; arr) {
}
     
// Pasamos una copia de &#39;arr&#39; en O(n)
// PUEDES leer de &#39;arr&#39; y PUEDES modificarlo
// PERO estas modificando la copia de &#39;arr&#39;, no el &#39;arr&#39; de &#39;main&#39;
void f3 (vector &lt;int&gt; arr) {
     
}
     
int main () {
  int n = 10000;
  vector &lt;int&gt; arr(n);
  for (int i = 0; i &lt; n; i++) {
    arr[i] = i;
  }
  f1(arr);
  f2(arr);
  f3(arr);
  return (0);
}</code></pre>
<p>Ahora, regresando al problema de generar el conjunto potencia de un conjunto. Primero, veamos un ejemplo pequeño. Si queremos generar el conjunto potencia de <span class="math inline">\(A = \{1, 2, 3\}\)</span>, podemos escribir una función que siga estos estados:</p>
<div class="row text-center">
<div class="figure">
<img src="images/class-09/power-set.png" />

</div>
</div>
<p>Esto es, si estamos en el estado <span class="math inline">\((a_1, a_2, \dots a_x) \mid a_1 &lt; a_2 &lt; \dots &lt; a_x\)</span>, entonces podemos ir al estado <span class="math inline">\((a_1, a_2, \dots, a_x, a_y) \mid a_x &lt; a_y \leq n\)</span>.</p>
<p>Y podemos implementar esta idea usando recursión así:</p>
<!-- begin code -->
<div class="collapsed code-title" type="button" data-toggle="collapse" data-target="#codeProblembacktrack-power-set" aria-expanded="false" aria-controls="collapseTwo">
<!-- title --> <i class="fas fa-caret-right"></i>
<p class="title">
Code
</p>
</div>
<div id="codeProblembacktrack-power-set" class="collapse">
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

void print (const vector &lt;int&gt;&amp; arr) {
  cout &lt;&lt; &quot;{&quot;;
  bool first = true;
  for (int elem: arr) {
    if (!first) {
      cout &lt;&lt; &quot;, &quot;;
    }
    cout &lt;&lt; elem;
    first = false;
  }
  cout &lt;&lt; &quot;}\n&quot;;
}

void backtrack (vector &lt;int&gt;&amp; arr, const int n) {
  print(arr);
  int ax = 0;
  if (!arr.empty()) {
    ax = arr.back();
  }
  for (int ay = ax + 1; ay &lt;= n; ay++) {
    // agrega ay
    arr.push_back(ay);
    backtrack(arr, n);
    // elimina ay
    arr.pop_back();
  }
}

int main () {
  int n = 3;
  vector &lt;int&gt; subset;
  backtrack(subset, n);
}</code></pre>
</div>
<p><!-- ends code --></p>
<p>Pero, en programación competitiva, es común tratar de tener pocos argumentos en nuestras funciones, por ello se suele hacer constante uso de variables globales. Por ejemplo, la anterior solución se puede modificar de esta manera (<strong>¿por qué?</strong>):</p>
<!-- begin code -->
<div class="collapsed code-title" type="button" data-toggle="collapse" data-target="#codeProblembacktrack-power-set-global" aria-expanded="false" aria-controls="collapseTwo">
<!-- title --> <i class="fas fa-caret-right"></i>
<p class="title">
Code
</p>
</div>
<div id="codeProblembacktrack-power-set-global" class="collapse">
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

void print (const vector &lt;int&gt;&amp; arr) {
  cout &lt;&lt; &quot;{&quot;;
  bool first = true;
  for (int elem: arr) {
    if (!first) {
      cout &lt;&lt; &quot;, &quot;;
    }
    cout &lt;&lt; elem;
    first = false;
  }
  cout &lt;&lt; &quot;}\n&quot;;
}

// variables globales
vector &lt;int&gt; subset;
int n;

void backtrack () {
  print(subset);
  int ax = 0;
  if (!subset.empty()) {
    ax = subset.back();
  }
  for (int ay = ax + 1; ay &lt;= n; ay++) {
    // add ay
    subset.push_back(ay);
    backtrack();
    // delete ay
    subset.pop_back();
  }
}

int main () {
  n = 3;
  backtrack();
}</code></pre>
</div>
<p><!-- ends code --></p>
<p>Así, hemos implementado un programa que encuentra el conjunto potencia del conjunto <span class="math inline">\(\{1, 2, 3, \dots, n\}\)</span> en <span class="math inline">\(O(n 2 ^ n)\)</span>. Las soluciones presentadas han usado una técnica conocida como <code>backtracking</code>. En general, una solución backtracking tiene esta forma:</p>
<pre class="bw"><code>sea state una variable global

T backtrack (algunos parámetros):
  if (state es un estado terminal):
    Realiza algo con &#39;state&#39; y retorna algo
  
  for (state&#39; alcanzable desde state):
    # Realiza algo
    previous = state
    state = state&#39;
    backtrack(algunos parámetros&#39;)
    # Revierte cambios
    state = previous</code></pre>
<p>Un estado terminal es un estado en donde ya no podemos ir a otros estados (o donde no es conveniente seguir buscando).</p>
<p>Veamos como podemos usar esta técnica en <a href="https://abc125.contest.atcoder.jp/tasks/abc125_b?lang=en">este problema</a>.</p>
<p>Podemos tomar los elementos de indices <span class="math inline">\(\{i_1, i_2, \dots, i_k\} \subseteq \{1, 2, 3, \dots, n\}\)</span>. Así, podemos buscar la solución en el conjunto potencia de <span class="math inline">\(\{1, 2, 3, \dots, n\}\)</span> usando backtracking.</p>
<!-- begin code -->
<div class="collapsed code-title" type="button" data-toggle="collapse" data-target="#codeProblemresale" aria-expanded="false" aria-controls="collapseTwo">
<!-- title --> <i class="fas fa-caret-right"></i>
<p class="title">
Code
</p>
</div>
<div id="codeProblemresale" class="collapse">
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
     
#define all(A) begin(A), end(A)
#define rall(A) rbegin(A), rend(A)
#define sz(A) int(A.size())
#define pb push_back
#define mp make_pair
     
using namespace std;
     
typedef long long ll;
typedef pair &lt;int, int&gt; pii;
typedef vector &lt;int&gt; vi;
typedef vector &lt;ll&gt; vll;

int n;
vi v, c;

int backtrack (int pos, int x, int y) {
  if (pos == n) return x - y;
  return max(backtrack(pos + 1, x + v[pos], y + c[pos]), backtrack(pos + 1, x, y));
}

int main () {
  ios::sync_with_stdio(false); cin.tie(0);
  cin &gt;&gt; n;
  v.resize(n);
  c.resize(n);
  for (int&amp; elem: v) cin &gt;&gt; elem;
  for (int&amp; elem: c) cin &gt;&gt; elem;
  cout &lt;&lt; backtrack(0, 0, 0) &lt;&lt; &#39;\n&#39;;
  return (0);
}</code></pre>
</div>
<p><!-- ends code --></p>
<div class="topic">
El problema de la mochila 0-1
</div>
<p><strong>Problema:</strong> Tienes una mochila de capaidad <span class="math inline">\(W\)</span> (i.e puedes poner como máximo <span class="math inline">\(W\)</span> kg en la mochila). Además, tienes <span class="math inline">\(n\)</span> accesorios. Cada accesorio es descrito como un par <span class="math inline">\((val_i, w_i)\)</span>, donde <span class="math inline">\(val_i\)</span> es el costo de ese accesorio y <span class="math inline">\(w_i\)</span> su peso. Encuentra el máximo valor que puedes guardar en la mochila usando el menor peso posible.</p>
<p><span class="math display">\[1 \leq n \leq 16\]</span></p>
<p><strong>Solución:</strong></p>
<p>Cada accesorio puedes ser tomado o no, entonces podemos buscar por todas las posibilidades (conjunto potencia) usando backtracking.</p>
<!-- begin code -->
<div class="collapsed code-title" type="button" data-toggle="collapse" data-target="#codeProblem0-1-knapsack" aria-expanded="false" aria-controls="collapseTwo">
<!-- title --> <i class="fas fa-caret-right"></i>
<p class="title">
Code
</p>
</div>
<div id="codeProblem0-1-knapsack" class="collapse">
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

int n;
int W;
vector &lt;int&gt; val;
vector &lt;int&gt; w;
vector &lt;int&gt; take;
int max_sum_val = 0;
int min_sum_w = 0;
vector &lt;int&gt; ans_items_taken;

void backtrack (int last_taken, int sum_val, int sum_w) {
  if (sum_w &lt;= W and (sum_val &gt; max_sum_val or
      (sum_val == max_sum_val and sum_w &lt; min_sum_w))) {
    max_sum_val = sum_val;
    min_sum_w = sum_w;
    ans_items_taken = take;
  }
  for (int i = last_taken + 1; i &lt; n; i++) {
    take.push_back(i);
    backtrack(i, sum_val + val[i], sum_w + w[i]);
    take.pop_back();
  }
}

int main () {
  n = 3;
  W = 10;
  // item 1
  val.push_back(10);
  w.push_back(10);
  // item 2
  val.push_back(1);
  w.push_back(8);
  // item 3
  val.push_back(13);
  w.push_back(2);
  backtrack(-1, 0, 0);

  cout &lt;&lt; &quot;Take items&quot;;
  for (int item: ans_items_taken) {
    cout &lt;&lt; &#39; &#39; &lt;&lt; item + 1;
  }
  cout &lt;&lt; &#39;\n&#39;;
  return (0);
}</code></pre>
</div>
<p><!-- ends code --></p>
<div class="topic">
Permutaciones
</div>
<p>El problema de generar todas las permutaciones puede ser fácilmente resuelto en <span class="math inline">\(O(n n!)\)</span> usando backtracking.</p>
<!-- begin code -->
<div class="collapsed code-title" type="button" data-toggle="collapse" data-target="#codeProblempermutation" aria-expanded="false" aria-controls="collapseTwo">
<!-- title --> <i class="fas fa-caret-right"></i>
<p class="title">
Code
</p>
</div>
<div id="codeProblempermutation" class="collapse">
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

int n;
vector &lt;bool&gt; used;
vector &lt;int&gt; permutation;

void print (const vector &lt;int&gt;&amp; p) {
  for (int elem: p) {
    cout &lt;&lt; elem &lt;&lt; &#39; &#39;;
  }
  cout &lt;&lt; &#39;\n&#39;;
}

void backtrack () {
  if (permutation.size() == n) {
    print(permutation);
    return;
  }
  for (int p_i = 1; p_i &lt;= n; p_i++) {
    if (!used[p_i]) {
      used[p_i] = true;
      permutation.push_back(p_i);
      backtrack();
      used[p_i] = false;
      permutation.pop_back();
    }
  }
}

int main () {
  n = 3;
  used.resize(n + 1, false);
  backtrack();
  return (0);
}</code></pre>
</div>
<p><!-- ends code --></p>
<p>Aqui estamos siguiendo estos estados:</p>
<div class="row text-center">
<div class="figure">
<img src="images/class-09/permutation.png" />

</div>
</div>
<p>Esta imagen representa lo que se conoce como el <strong>árbol de recursión</strong>, ese nos muestra como la función hace las transiciones.</p>
<p>Además, notamos que no necesitamos hacer algo como esto:</p>
<pre class="cpp"><code>.
.
.
  for (int p_i = 1; p_i &lt;= n; p_i++) {
    if (!used[p_i]) {
      vector &lt;bool&gt; used_previous = used;
      vector &lt;int&gt; permutation_previous = permutation;
      used[p_i] = true;
      permutation.push_back(p_i);
      backtrack();
      used = used_previous;
      permutation = permutation_previous;
    }
  }
.
.
.</code></pre>
<p>Porque esto sería más pesado que la primera solucion y porque sabemos que:</p>
<ul>
<li>Si antes de llamar a la recursión AGREGAMOS un elemento AL FINAL del vector, entonces después de la recursión debemos ELIMINAR EL ÚLTIMO elemento.</li>
<li>Si anter de llamar a la recursión SETEAMOS A TRUE un elemento, entonces despues de la recursión debemos SETEAR A SU VALOR ORIGINAL el elemento.</li>
<li>Si antes de llamar a la recursión AGREGAMOS algo, entonces después de la recursión debemos ELIMINAR lo que agregamos.</li>
<li>Siguiendo esta lógica, si antes de llamar a la función recursiva HACEMOS UNA OPERACIÓN, entonces después de la recursión debemos REVERTIR LA OPERACIÓN.</li>
</ul>
<p>De estas observaciones notamos que cuando en tu recursión estás en <code>estado</code> y vas a <code>state'</code>, entonces después de recorrer el árbol de recursion de <code>state'</code> debes tener las variables en el mismo estado previo a comenzar la recursión por el árbol de <code>state'</code>. Entender estas observaciones es clave para entender backtracking.</p>
<div class="topic">
Sudoku
</div>
<p>Con backtracking es fácil generar todas los posibles movimientos de un juego y escoger el mejor movimiento.</p>
<p><strong>Problema:</strong></p>
<div class="row text-center">
<div class="figure">
<img src="images/class-09/sudoku1.png" />

</div>
</div>
<p>Completa el sudoku de arriba de tal manera que cada número del 1 al 9 es encontrado solo una vez en cada fila, columna y cuadrante.</p>
<p><strong>Solución:</strong> Podemos buscar todas las posibilidades usando backtracking.</p>
<!-- begin code -->
<div class="collapsed code-title" type="button" data-toggle="collapse" data-target="#codeProblemsudoku" aria-expanded="false" aria-controls="collapseTwo">
<!-- title --> <i class="fas fa-caret-right"></i>
<p class="title">
Code
</p>
</div>
<div id="codeProblemsudoku" class="collapse">
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

vector &lt;vector &lt;int&gt;&gt; sudoku;
vector &lt;vector &lt;int&gt;&gt; sudoku_solved;
vector &lt;vector &lt;pair &lt;int, int&gt;&gt;&gt; quadrant;
int n;
int N;
bool found;

bool validInRow (int r, int d) {
  for (int c = 0; c &lt; N; c++) {
    if (sudoku[r][c] == d) return false;
  }
  return true;
}

bool validInCol (int c, int d) {
  for (int r = 0; r &lt; N; r++) {
    if (sudoku[r][c] == d) return false;
  }
  return true;
}

bool validInQuadrant (int q, int d) {
  for (pair &lt;int, int&gt; pos: quadrant[q]) {
    int r = pos.first;
    int c = pos.second;
    if (sudoku[r][c] == d) return false;
  }
  return true;
}

// corre esta funcion for cada 0 &lt;= r &lt; N and 0 &lt;= c &lt; N
// y entederás que es lo que hace
int getQuadrant (int r, int c) {
  return (r / n) * n + (c / n);
}

void backtrack (int r, int c) {
  if (r == N) {
    found = true;
    sudoku_solved = sudoku;
    return;
  }
  if (found) {
    return;
  }
  int nc = (c + 1 == N) ? 0 : c + 1; // new column
  int nr = (c + 1 == N) ? r + 1 : r; // new row
  if (sudoku[r][c] != 0) {
    backtrack(nr, nc);
    return;
  } 
  for (int d = 1; d &lt;= 9; d++) {
    int quadrant = getQuadrant(r, c);
    if (validInRow(r, d) and
        validInCol(c, d) and
        validInQuadrant(getQuadrant(r, c), d)) {
      sudoku[r][c] = d;
      backtrack(nr, nc);
      sudoku[r][c] = 0;
    }
  }
}

void precomputation () {
  found = false;
  N = sudoku.size();
  n = 1;
  while ((n + 1) * (n + 1) &lt;= N) n++;
  // n = sqrt(N)
  quadrant.resize(N);
  for (int r = 0; r &lt; N; r++) {
    for (int c = 0; c &lt; N; c++) {
      quadrant[getQuadrant(r, c)].push_back({r, c});
    }
  }
}

void print (const vector &lt;vector &lt;int&gt;&gt;&amp; sudoku) {
  for (auto row: sudoku) {
    for (int elem: row) {
      cout &lt;&lt; elem &lt;&lt; &#39; &#39;;
    }
    cout &lt;&lt; &#39;\n&#39;;
  }
}

int main () {
  sudoku = {
            {3, 0, 6, 5, 0, 8, 4, 0, 0},  
            {5, 2, 0, 0, 0, 0, 0, 0, 0},  
            {0, 8, 7, 0, 0, 0, 0, 3, 1},  
            {0, 0, 3, 0, 1, 0, 0, 8, 0},  
            {9, 0, 0, 8, 6, 3, 0, 0, 5},  
            {0, 5, 0, 0, 9, 0, 6, 0, 0},  
            {1, 3, 0, 0, 0, 0, 2, 5, 0},  
            {0, 0, 0, 0, 0, 0, 0, 7, 4},  
            {0, 0, 5, 2, 0, 6, 3, 0, 0}
           };
  precomputation();
  backtrack(0, 0);
  print(sudoku_solved);
  return (0);
}</code></pre>
</div>
<p><!-- ends code --></p>
<p>Con este código podemos obtener esta solución:</p>
<div class="row text-center">
<div class="figure">
<img src="images/class-09/sudoku2.png" />

</div>
</div>
<div class="topic">
El problema de las N-reinas
</div>
<p><strong><a href="https://www.hackerearth.com/practice/basic-programming/recursion/recursion-and-backtracking/tutorial/">Problema:</a></strong></p>
<p>Dado un tablero de ajedrez de <span class="math inline">\(N \times N\)</span> celdas, debes colocar <span class="math inline">\(N\)</span> reinas en el tablero de tal manera que no se ataquen.</p>
<p><span class="math display">\[1 \leq N \leq 10\]</span></p>
<p><strong>Recuerda:</strong> Una reina puede atacar en toda una fila, columna o diagonal.</p>
<p><strong>Solución:</strong> Podemos intentar poner <span class="math inline">\(N\)</span> reinas en las <span class="math inline">\(N \times N\)</span> celdas. De esta manera tendríamos <span class="math inline">\(\binom{N \times N}{N}\)</span> estados que verificar. Pero para <span class="math inline">\(N = 8\)</span> tenemos <span class="math inline">\(\binom{N \times N}{N} \approx 8B\)</span> estados, entonces necesitamos un mejor enfoque.</p>
<p>Sabemos que cada reina debe estar en distintas columnas (sino ellas se estarían atacando entre sí). Entonces podemos generar estas <span class="math inline">\(N^N\)</span> configuraciones y revisar si las condiciones se cumplen. Pero para este problema este enfoque no es suficiente.</p>
<p>Analizando un poco nos damos cuenta que cada reina debe estar en una fila y columna distinta. Así, las filas de las posiciones de las reinas en una configuración válida forman son una permutación de <span class="math inline">\(\{ 1, 2, \dots, n }\)</span>, lo mismo se cumple con las columnas. De este modo, tenemos <span class="math inline">\(N!\)</span> posibles configuraciones que revisar y podemos implementar este enfoque con backtracking.</p>
<!-- begin code -->
<div class="collapsed code-title" type="button" data-toggle="collapse" data-target="#codeProblemn-queen" aria-expanded="false" aria-controls="collapseTwo">
<!-- title --> <i class="fas fa-caret-right"></i>
<p class="title">
Code
</p>
</div>
<div id="codeProblemn-queen" class="collapse">
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

int n;
vector &lt;pair &lt;int, int&gt;&gt; queen;
vector &lt;pair &lt;int, int&gt;&gt; solution;

bool valid (int r, int c) {
  for (auto pp: queen) {
    // if same row or same column or same diagonal
    if ((pp.first == r) or
        (pp.second == c) or
        (abs(r - pp.first) == abs(c - pp.second))) {
      return false;
    }
  }
  return true;
}

void backtrack (int r) {
  if (r == n) {
    solution = queen;
    return;
  }
  if (!solution.empty()) {
    return;
  }
  for (int c = 0; c &lt; n; c++) {
    if (valid(r, c)) {
      queen.push_back({r, c});
      backtrack(r + 1);
      queen.pop_back();
    }
  }
}

int main () {
  cin &gt;&gt; n;
  backtrack(0);
  if (solution.empty()) {
    cout &lt;&lt; &quot;NO\n&quot;;
    return (0);
  }
  vector &lt;vector &lt;int&gt;&gt; board(n, vector &lt;int&gt; (n, 0));
  for (auto pp: solution) {
    board[pp.first][pp.second] = 1;
  }
  cout &lt;&lt; &quot;YES\n&quot;;
  for (int r = 0; r &lt; n; r++) {
    for (int c = 0; c &lt; n; c++) {
      cout &lt;&lt; board[r][c] &lt;&lt; &quot; \n&quot;[c == n - 1];
    }
  }
  return (0);
}</code></pre>
</div>
<p><!-- ends code --></p>
<p>Para <span class="math inline">\(N = 4\)</span> el árbol de recursión de nuestra solución luce así:</p>
<div class="row text-center">
<div class="figure">
<img src="images/class-09/n-queen.png" />

</div>
</div>
<p>Imagen tomada de <a href="http://jeffe.cs.illinois.edu/teaching/algorithms/">Jeff Erickson - Algorithms - Chapter 2: Backtracking</a>.</p>
<p>La complejidad de la anterior solución viene de la equación:</p>
<p><span class="math display">\[T_n = n \cdot T_{n - 1} + O(n)\]</span> <span class="math display">\[\to T_n = O(n!)\]</span></p>
<p>Así, nuestra solución tiene complejidad <span class="math inline">\(O(n!)\)</span>.</p>
<p>Lecturas recomendadas:</p>
<ul>
<li><a href="https://www.hackerearth.com/practice/basic-programming/recursion/recursion-and-backtracking/tutorial/">HackerEarth - Recursion and Backtracking</a></li>
<li>Competitive Programming 3, secciones 3.2.2, 8.2.1 and 8.2.2.</li>
<li><a href="https://www.geeksforgeeks.org/backtracking-algorithms/">GeekForGeeks - Backtracking Algorithms</a></li>
</ul>
<p>También te podría interesar ver este documental de AlphaGo. <a href="https://youtu.be/8tq1C8spV_g">Aquí</a> está el trailler.</p>
<div id="contest" class="topic">
Contest
</div>
<p>El contest lo puedes encontrar <a href="https://vjudge.net/contest/355270">aquí</a>.</p>
<!-- Begins problem A -->
<div id="A" class="card">
<div class="collapsed solution-title" type="button" data-toggle="collapse" data-target="#collapseProblemA" aria-expanded="false" aria-controls="collapseTwo">
<!-- title -->
<i class="fas fa-caret-right"></i>
<p class="title">
A: CD
</p>
</div>
<!-- begin body -->
<div id="collapseProblemA" class="collapse">
<div class="card-body solution-body">
<h3 id="cd"><a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=565" target="_blank">CD</a></h3>
<p>Cada elemento puede o no ser tomado, entonces podemos implementar una solución backtracking; además, de esta manera podemos mantener el orden inicial de los elementos.</p>
<!-- begin code -->
<div class="collapsed code-title" type="button" data-toggle="collapse" data-target="#codeProblemA" aria-expanded="false" aria-controls="collapseTwo">
<!-- title --> <i class="fas fa-caret-right"></i>
<p class="title">
Code
</p>
</div>
<div id="codeProblemA" class="collapse">
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
     
using namespace std;
 
int main () {
  int n;
  while (cin &gt;&gt; n) {
    int m;
    cin &gt;&gt; m;
    vector &lt;int&gt; arr(m);
    for (int&amp; elem: arr) cin &gt;&gt; elem;
    vector &lt;int&gt; take;
    vector &lt;int&gt; ans;
    int sum = 0;
    int best_sum = 0;

    function &lt;void(int)&gt; backtrack = [&amp;] (int pos) -&gt; void {
      if (sum &gt; best_sum or (sum == best_sum and ans.size() &lt; take.size())) {
        best_sum = sum;
        ans = take;
      }
      if (pos == m) return;
      // do not take it
      backtrack(pos + 1);
      if (sum + arr[pos] &gt; n) return;
      // take it
      take.push_back(arr[pos]);
      sum += arr[pos];
      backtrack(pos + 1);
      take.pop_back();
      sum -= arr[pos];
    };

    backtrack(0);
    for (int elem: ans) cout &lt;&lt; elem &lt;&lt; &#39; &#39;;
    cout &lt;&lt; &quot;sum:&quot; &lt;&lt; best_sum &lt;&lt; &#39;\n&#39;;
  }
  return (0);
}</code></pre>
</div>
<p><!-- ends code --></p>
</div>
</div>
</div>
<!-- ends problem A -->
<!-- Begins problem B -->
<div id="B" class="card">
<div class="collapsed solution-title" type="button" data-toggle="collapse" data-target="#collapseProblemB" aria-expanded="false" aria-controls="collapseTwo">
<!-- title -->
<i class="fas fa-caret-right"></i>
<p class="title">
B: Hanoi Tower Troubles Again!
</p>
</div>
<!-- begin body -->
<div id="collapseProblemB" class="collapse">
<div class="card-body solution-body">
<h3 id="hanoi-tower-troubles-again"><a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1217" target="_blank">Hanoi Tower Troubles Again!</a></h3>
<p>Hay un enfoque greedy: pon el balón en la primera pila donde puedas ponerlo.</p>
<!-- begin code -->
<div class="collapsed code-title" type="button" data-toggle="collapse" data-target="#codeProblemB" aria-expanded="false" aria-controls="collapseTwo">
<!-- title --> <i class="fas fa-caret-right"></i>
<p class="title">
Code
</p>
</div>
<div id="codeProblemB" class="collapse">
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

int main () {
  const int N = 1e5;
  vector &lt;bool&gt; is_sq(N, false);
  for (int i = 0; i * i &lt; N; i++) is_sq[i * i] = true;
  int tc;
  cin &gt;&gt; tc;
  while (tc--) {
    int n;
    cin &gt;&gt; n;
    vector &lt;vector &lt;int&gt;&gt; pile(n);
    int ans = 0;
    int cur = 0;

    function &lt;void(int)&gt; rec = [&amp;] (int num) -&gt; void {
      ans = max(ans, cur);
      for (int i = 0; i &lt; n; i++) {
        if (pile[i].empty() or is_sq[pile[i].back() + num]) {
          cur += 1;
          pile[i].push_back(num);
          rec(num + 1);
          break;
        }
      }
    };

    rec(1);
    cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;
  }
  return (0);
}</code></pre>
</div>
<p><!-- ends code --></p>
</div>
</div>
</div>
<!-- ends problem B -->
<!-- Begins problem C -->
<div id="C" class="card">
<div class="collapsed solution-title" type="button" data-toggle="collapse" data-target="#collapseProblemC" aria-expanded="false" aria-controls="collapseTwo">
<!-- title -->
<i class="fas fa-caret-right"></i>
<p class="title">
C: Marcus
</p>
</div>
<!-- begin body -->
<div id="collapseProblemC" class="collapse">
<div class="card-body solution-body">
<h3 id="marcus"><a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1393" target="_blank">Marcus</a></h3>
<p>Identifica el punto inicial y luego busca en la matriz usando backtracking.</p>
<!-- begin code -->
<div class="collapsed code-title" type="button" data-toggle="collapse" data-target="#codeProblemC" aria-expanded="false" aria-controls="collapseTwo">
<!-- title --> <i class="fas fa-caret-right"></i>
<p class="title">
Code
</p>
</div>
<div id="codeProblemC" class="collapse">
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

int main () {
  const vector &lt;int&gt; dr = {-1, 0, 0};
  const vector &lt;int&gt; dc = {0, -1, 1};
  const vector &lt;string&gt; option = {&quot;forth&quot;, &quot;left&quot;, &quot;right&quot;};
  const string word = &quot;IEHOVA#&quot;;
  int tc;
  cin &gt;&gt; tc;
  while (tc--) {
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    vector &lt;string&gt; ans;
    vector &lt;string&gt; take;
    vector &lt;string&gt; grid(n);
    for (int i = 0; i &lt; n; i++) cin &gt;&gt; grid[i];

    function &lt;void(int,int)&gt; backtrack = [&amp;] (int r, int c) -&gt; void {
      if (take.size() == 7) {
        ans = take;
        return;
      }
      for (int d = 0; d &lt; 3; d++) {
        if (!ans.empty()) return;
        int nr = r + dr[d];
        int nc = c + dc[d];
        if (not (0 &lt;= min(nr, nc) and nr &lt; n and nc &lt; m)) continue;
        if (grid[nr][nc] != word[take.size()]) continue;
        take.push_back(option[d]);
        backtrack(nr, nc);
        take.pop_back();
      }
    };

    for (int r = 0; r &lt; n; r++) {
      for (int c = 0; c &lt; m; c++) {
        if (grid[r][c] == &#39;@&#39;) {
          backtrack(r, c);
        }
      }
    }
    for (int i = 0; i &lt; 7; i++) {
      cout &lt;&lt; ans[i] &lt;&lt; &quot; \n&quot;[i == 6];
    }
  }
  return (0);
}</code></pre>
</div>
<p><!-- ends code --></p>
</div>
</div>
</div>
<!-- ends problem C -->
<!-- Begins problem D -->
<div id="D" class="card">
<div class="collapsed solution-title" type="button" data-toggle="collapse" data-target="#collapseProblemD" aria-expanded="false" aria-controls="collapseTwo">
<!-- title -->
<i class="fas fa-caret-right"></i>
<p class="title">
D: Back to the 8-Queens
</p>
</div>
<!-- begin body -->
<div id="collapseProblemD" class="collapse">
<div class="card-body solution-body">
<h3 id="back-to-the-8-queens"><a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2026" target="_blank">Back to the 8-Queens</a></h3>
<p>Solo hay 92 configuraciones válidas, puedes generarlas con backtracking y luego solo hacer una busqueda lineal por cada test.</p>
<!-- begin code -->
<div class="collapsed code-title" type="button" data-toggle="collapse" data-target="#codeProblemD" aria-expanded="false" aria-controls="collapseTwo">
<!-- title --> <i class="fas fa-caret-right"></i>
<p class="title">
Code
</p>
</div>
<div id="codeProblemD" class="collapse">
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

const int N = 8;
vector &lt;pair &lt;int, int&gt;&gt; queen;
vector &lt;vector &lt;pair &lt;int, int&gt;&gt;&gt; solution;

bool valid (int r, int c) {
  for (auto pp: queen) {
    // if same row or same column or same diagonal
    if ((pp.first == r) or
        (pp.second == c) or
        (abs(r - pp.first) == abs(c - pp.second))) {
      return false;
    }
  }
  return true;
}

void backtrack (int c) {
  if (c == N + 1) {
    solution.push_back(queen);
    return;
  }
  for (int r = 1; r &lt;= N; r++) {
    if (valid(r, c)) {
      queen.push_back({r, c});
      backtrack(c + 1);
      queen.pop_back();
    }
  }
}

int main () {
  backtrack(1);
  vector &lt;int&gt; row(N);
  int tc = 0;
  while (cin &gt;&gt; row[0]) {
    for (int i = 1; i &lt; N; i++) cin &gt;&gt; row[i];
    int ans = INT_MAX;
    for (auto sol: solution) {
      int need = 0;
      for (int i = 0; i &lt; N; i++) {
        need += (row[i] != sol[i].first);
      }
      ans = min(ans, need);
    }
    cout &lt;&lt; &quot;Case &quot; &lt;&lt; ++tc &lt;&lt; &quot;: &quot; &lt;&lt; ans &lt;&lt; &#39;\n&#39;;
  }
  return (0);
}</code></pre>
</div>
<p><!-- ends code --></p>
</div>
</div>
</div>
<!-- ends problem D -->
<!-- Begins problem E -->
<div id="E" class="card">
<div class="collapsed solution-title" type="button" data-toggle="collapse" data-target="#collapseProblemE" aria-expanded="false" aria-controls="collapseTwo">
<!-- title -->
<i class="fas fa-caret-right"></i>
<p class="title">
E: Boggle Blitz
</p>
</div>
<!-- begin body -->
<div id="collapseProblemE" class="collapse">
<div class="card-body solution-body">
<h3 id="boggle-blitz"><a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=428" target="_blank">Boggle Blitz</a></h3>
<p>Solo implementa una solución backtracking para hacer una búsqueda completa.</p>
<!-- begin code -->
<div class="collapsed code-title" type="button" data-toggle="collapse" data-target="#codeProblemE" aria-expanded="false" aria-controls="collapseTwo">
<!-- title --> <i class="fas fa-caret-right"></i>
<p class="title">
Code
</p>
</div>
<div id="codeProblemE" class="collapse">
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

int main () {
  int tc;
  cin &gt;&gt; tc;
  for (int t = 0; t &lt; tc; t++) {
    if (t) cout &lt;&lt; &#39;\n&#39;;
    int n;
    cin &gt;&gt; n;
    vector &lt;string&gt; grid(n);
    for (int i = 0; i &lt; n; i++) cin &gt;&gt; grid[i];
    vector &lt;string&gt; ans;
    string word = &quot;&quot;;

    function &lt;void(int,int,char)&gt; backtrack = [&amp;] (int r, int c, char last) -&gt; void {
      if (3 &lt;= word.size()) {
        ans.push_back(word);
      }
      for (int dr = -1; dr &lt;= 1; dr++) {
        for (int dc = -1; dc &lt;= 1; dc++) {
          if (dr == 0 and dc == 0) continue;
          int nr = r + dr;
          int nc = c + dc;
          if (not (0 &lt;= min(nr, nc) and max(nr, nc) &lt; n)) continue;
          if (grid[nr][nc] &lt;= last) continue;
          word += grid[nr][nc];
          backtrack(nr, nc, grid[nr][nc]);
          word.pop_back();
        }
      }
    };

    for (int r = 0; r &lt; n; r++) {
      for (int c = 0; c &lt; n; c++) {
        word += grid[r][c];
        backtrack(r, c, grid[r][c]);
        word.pop_back();
      }
    }
    sort(begin(ans), end(ans), [&amp;] (const string&amp; x, const string&amp; y) {
      if (x.size() != y.size()) return x.size() &lt; y.size();
      return x &lt; y;  
    });
    // delete duplicates
    ans.erase(unique(begin(ans), end(ans)), end(ans));
    for (auto&amp; word: ans) cout &lt;&lt; word &lt;&lt; &#39;\n&#39;;
  }
  return (0);
}</code></pre>
</div>
<p><!-- ends code --></p>
</div>
</div>
</div>
<!-- ends problem E -->




</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
