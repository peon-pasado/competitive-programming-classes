<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="GPC-UNI Resto del Mundo" />


<title>Training Camp Argentina 2020 - Editorial Contest 1 Avanzado</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<script src="site_libs/elevate-section-attrs-2.0/elevate-section-attrs.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/yeti.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/textmate.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>

<link rel="stylesheet" href="style.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 45px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 50px;
  margin-top: -50px;
}
.section h2 {
  padding-top: 50px;
  margin-top: -50px;
}
.section h3 {
  padding-top: 50px;
  margin-top: -50px;
}
.section h4 {
  padding-top: 50px;
  margin-top: -50px;
}
.section h5 {
  padding-top: 50px;
  margin-top: -50px;
}
.section h6 {
  padding-top: 50px;
  margin-top: -50px;
}
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #ffffff;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->




</head>

<body>


<div class="container-fluid main-container">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">GPC-UNI Resto del mundo</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="schedule.html">Cronograma</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Clases
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="class-01.html">Introducción</a>
    </li>
    <li>
      <a href="class-02.html">Complejidades + STL</a>
    </li>
    <li>
      <a href="class-03.html">Contest 1</a>
    </li>
    <li>
      <a href="class-04.html">Teoría de números</a>
    </li>
    <li>
      <a href="class-05.html">Fuerza bruta I</a>
    </li>
    <li>
      <a href="class-06.html">Fuerza bruta II</a>
    </li>
    <li>
      <a href="class-07.html">Contest 2</a>
    </li>
    <li>
      <a href="class-08.html">Recursión</a>
    </li>
    <li>
      <a href="class-09.html">Backtracking I</a>
    </li>
    <li>
      <a href="class-10.html">Recapitulacion I</a>
    </li>
    <li>
      <a href="class-11.html">Contest UNI-UTEC I</a>
    </li>
    <li>
      <a href="class-12.html">Backtracking II</a>
    </li>
    <li>
      <a href="class-13.html">Backtracking II</a>
    </li>
    <li>
      <a href="class-14.html">Bitmask</a>
    </li>
    <li>
      <a href="class-15.html">Introducción a Greedy</a>
    </li>
    <li>
      <a href="class-16.html">7 Greedy Problems</a>
    </li>
    <li>
      <a href="class-17.html">Meet in the middle</a>
    </li>
    <li>
      <a href="class-18.html">Dynamic Programming</a>
    </li>
    <li>
      <a href="class-19.html">Grafos</a>
    </li>
    <li>
      <a href="class-20.html">Divide and Conquer</a>
    </li>
    <li>
      <a href="class-21.html">DP Classics</a>
    </li>
    <li>
      <a href="class-22.html">Max Flow Introduction</a>
    </li>
    <li>
      <a href="class-23.html">Max Flow Algorithm</a>
    </li>
    <li>
      <a href="class-24.html">Sparse Table</a>
    </li>
    <li>
      <a href="class-25.html">Binary Indexed Tree</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    TC Argentina 2020
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="TCAC1-EditorialI.html">Editorial Contest 1 - Inicial</a>
    </li>
    <li>
      <a href="TCAC1-EditorialA.html">Editorial Contest 1 - Avanzado</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="daily-problem.html">Problema del día</a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">



<h1 class="title toc-ignore">Training Camp Argentina 2020 - Editorial Contest 1 Avanzado</h1>
<h4 class="author">GPC-UNI Resto del Mundo</h4>
<h4 class="date">13-07-2020</h4>

</div>


<div id="a.-nanamis-digital-board" class="section level2">
<h2><a href="https://codeforces.com/group/j1UosVRZar/contest/287329/problem/A">A. Nanami’s Digital Board</a></h2>
<p>Consideremos un problema similar: hallar el máximo bloque de luz de todo el tablero. Consideraremos que las restricciones de este problema son las mismas que para el problema original, pero sin operaciones extra.</p>
<p>Una idea con fuerza bruta sería fijar todos los 4 lados del bloque, verificar esto puede ser realizado con una matriz de acumulados, así que la complejidad sería <span class="math inline">\(O(n^{4})\)</span>. Obviamente esto nos daría un veredicto de TLE.</p>
<p>¿Por qué fijar los 4 lados? Mejor fijemos el lado inferior y el lado superior, de esta forma nuestro problema se vuelve 1D (considerando las columnas como un solo elemento) y puede ser resuelto de manera lineal. Nuestra complejidad ahora será <span class="math inline">\(O(n^{3})\)</span>, pero no es suficientemente rápido.</p>
<p>Intentemos fijar solamente el lado inferior, entonces lo que tendremos es un arreglo <span class="math inline">\(up[]\)</span>, el cual denotará la máxima “altura” de cada columna. Para ser más preciso, supongamos que el lado inferior se ubica en la fila <span class="math inline">\(x\)</span>, entonces <span class="math inline">\(up[i]\)</span> es el máximo valor tal que las celdas <span class="math inline">\((x, i), (x-1, i), \ldots, (x - up[i] + 1, i)\)</span> están con luz. Si elegimos las columnas <span class="math inline">\(l\)</span> y <span class="math inline">\(r\)</span> como los lados izquierdo y derecho, entonces el área del máximo bloque de luz con estos 3 lados fijos sería:</p>
<p><span class="math display">\[ (r - l + 1)\left(\min_{l \leq i \leq r}{\{up[i]\}}\right) \]</span></p>
<p>Sea <span class="math inline">\(h = \min_{l \leq i \leq r}{\\{up[i]\\}}\)</span>, ¿Qué tal si fijamos <span class="math inline">\(h\)</span> y hallamos el <span class="math inline">\(l\)</span> más a la izquierda y el <span class="math inline">\(r\)</span> más a la derecha? Para ser más preciso, fijamos una columna <span class="math inline">\(p\)</span> y consideremos que la altura de esta columna sea la altura del bloque. Ahora queremos “extender” los lados hacia la izquierda y derecha del bloque, así que buscaremos la columna más hacia la izquierda tal que <span class="math inline">\(\min_{l \leq i \leq r}{\\{up[i]\\}} = up[p]\)</span>. De manera análoga, buscaremos la columna más a la derecha que cumpla y el máximo bloque de luz con su altura fijada en la columna <span class="math inline">\(p\)</span> será <span class="math inline">\((r - l + 1)\cdot up[p]\)</span>.</p>
<p>Este enfoque puede ser optimizado usando DSU. Imaginemos que inicialmente el arreglo <span class="math inline">\(up[]\)</span> está vacío. Agreguemos los elementos de <span class="math inline">\(up[]\)</span> uno por uno, de mayor a menor. Usaremos dos DSUs denotados por <span class="math inline">\(L\)</span> y <span class="math inline">\(R\)</span>. Cuando agregamos un elemento <span class="math inline">\(up[i]\)</span>, asignamos el padre de <span class="math inline">\(i\)</span> como <span class="math inline">\(i+1\)</span> en <span class="math inline">\(R\)</span> y como <span class="math inline">\(i-1\)</span> en <span class="math inline">\(L\)</span>. De esta forma basta con hallar el padre de <span class="math inline">\(i\)</span> en <span class="math inline">\(L\)</span> y <span class="math inline">\(R\)</span> para obtener los extremos <span class="math inline">\(l\)</span> y <span class="math inline">\(r\)</span>.</p>
<p>Ahora este problema puede resolverse en complejidad casi cuadrática. De hecho, podríamos optimizarlo a complejidad cuadrática usando colas monótonas (Min/Max Queue), pero no es necesario por ahora. Volvamos al problema original.</p>
<p>Supongamos que no hay modificaciones y que las operaciones solo son consultas. Entonces, podríamos mantener el arreglo <span class="math inline">\(up\)</span> de cada fila, y de manera análoga mantener <span class="math inline">\(down[]\)</span>, <span class="math inline">\(left[]\)</span>, <span class="math inline">\(right[]\)</span> para cada posible rotación. Usaremos el enfoque visto anteriormente para responder una consulta en tiempo casi lineal.</p>
<p>Ahora consideremos las modificaciones. La modificación de un solo pixel solo cambia los valores de <span class="math inline">\(O(n + m)\)</span> posiciones de los arreglos, así que las modificaciones pueden ser resueltas en tiempo lineal.</p>
<p>La complejidad total del algoritmo es <span class="math inline">\(O(n^{2} +  q\cdot n \cdot \alpha(n))\)</span>, donde <span class="math inline">\(\alpha(n)\)</span> es la inversa de la función de Ackermann, la cual se ve muy seguido en el análisis de la complejidad de los DSUs.</p>
<!-- begin code -->
<div class="collapsed code-title" type="button" data-toggle="collapse" data-target="#codeExample1" aria-expanded="false" aria-controls="collapseTwo">
<!-- title -->
<i class="fas fa-caret-right"></i>
<p class="title">
Código (por Fischer)
</p>
</div>
<div id="codeExample1" class="collapse">
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
 
const int maxn = 1005;
int u[maxn][maxn];
int d[maxn][maxn];
int l[maxn][maxn];
int r[maxn][maxn];
int n, m, q;
int link[2][maxn];
int rnk[2][maxn];
bool mat[maxn][maxn];
int cst[maxn];
int mini[2][maxn];
int maxi[2][maxn];
 
void init(int n) {
    for (int i = 0; i &lt;= n + 1; ++i) {
        link[0][i] = link[1][i] = i;
        rnk[0][i] = rnk[1][i] = 0;
        mini[0][i] = maxi[0][i] = i;
        mini[1][i] = maxi[1][i] = i;
    }
}
 
int get(int idx, int x) {
    if (x == link[idx][x]) return x;
    return link[idx][x] = get(idx, link[idx][x]);
}
 
void merge(int idx, int x, int y) {
    x = get(idx, x); 
    y = get(idx, y);
    if (x == y) return;
    if (rnk[idx][x] &lt; rnk[idx][y]) swap(x, y);
    rnk[idx][x] += rnk[idx][x] == rnk[idx][y];
    link[idx][y] = x;
    mini[idx][x] = min(mini[idx][x], mini[idx][y]);
    maxi[idx][x] = max(maxi[idx][x], maxi[idx][y]);
}
 
int p(int n, int idx) {
    vector&lt;pair&lt;int, int&gt;&gt; order;
    for (int i = 1; i &lt;= n; ++i) {
        order.emplace_back(cst[i], i);
    }
    init(n);
    sort(order.rbegin(), order.rend());
    int ans = 0;
    for (auto e : order) {
        int u = mini[0][get(0, e.second-1)] + 1;
        int v = maxi[1][get(1, e.second+1)] - 1;
        if (u &lt;= idx &amp;&amp; idx &lt;= v) {
            ans = max(ans, (v-u+1) * cst[e.second]);
        }
        merge(0, e.second, e.second-1);
        merge(1, e.second, e.second+1);
    }
    return ans;
}
 
int main() {
    scanf(&quot;%d %d %d&quot;, &amp;n, &amp;m, &amp;q);
    for (int i = 1; i &lt;= n; ++i) {
        for (int j = 1; j &lt;= m; ++j) {
            int x;
            scanf(&quot;%d&quot;, &amp;x);
            mat[i][j] = x;
        }
    }
    for (int i = 1; i &lt;= n; ++i) {
        for (int j = 1; j &lt;= m; ++j) {
            if (mat[i][j]) {
                u[i][j] = u[i-1][j] + 1;
                l[i][j] = l[i][j-1] + 1;
            } else {
                u[i][j] = 0;
                l[i][j] = 0;
            }
        }
    }
    for (int i = n; i &gt;= 1; --i) {
        for (int j = m; j &gt;= 1; --j) {
            if (mat[i][j]) { 
                d[i][j] = d[i+1][j] + 1;
                r[i][j] = r[i][j+1] + 1;
            } else {
                d[i][j] = 0;
                r[i][j] = 0;
            }
        }
    }
    while (q--) {
        int type, a, b;
        scanf(&quot;%d %d %d&quot;, &amp;type, &amp;a, &amp;b);
        if (type == 1) {
            mat[a][b] = 1 - mat[a][b];
            for (int i = a; i &lt;= n; ++i) {
                if (mat[i][b]) {
                    u[i][b] = u[i-1][b] + 1;
                } else {
                    u[i][b] = 0;
                }
            }
            for (int i = a; i &gt;= 1; --i) {
                if (mat[i][b]) {
                    d[i][b] = d[i+1][b] + 1;
                } else {
                    d[i][b] = 0;
                }
            }
            for (int i = b; i &lt;= m; ++i) {
                if (mat[a][i]) {
                    l[a][i] = l[a][i-1] + 1;
                } else {
                    l[a][i] = 0;
                }
            }
            for (int i = b; i &gt;= 1; --i) {
                if (mat[a][i]) {
                    r[a][i] = r[a][i+1] + 1;
                } else {
                    r[a][i] = 0;
                }
            }
        } else {
            int ans = 0;
            for (int i = 1; i &lt;= m; ++i) {
                cst[i] = u[a][i];
            }
            ans = max(ans, p(m, b));
            for (int i = 1; i &lt;= m; ++i) {
                cst[i] = d[a][i];
            }
            ans = max(ans, p(m, b));
            for (int i = 1; i &lt;= n; ++i) {
                cst[i] = l[i][b];
            }
            ans = max(ans, p(n, a));
            for (int i = 1; i &lt;= n; ++i) {
                cst[i] = r[i][b];
            }
            printf(&quot;%d\n&quot;, max(ans, p(n, a)));
        }
    }
    return 0;
}</code></pre>
</div>
<!-- ends code -->
</div>
<div id="b.-new-year-and-permutation" class="section level2">
<h2><a href="https://codeforces.com/group/j1UosVRZar/contest/287329/problem/B">B. New Year and Permutation</a></h2>
<p>Para este problema basta con considerar los subarreglos de tamaño <span class="math inline">\(L\)</span> y considerar su aporte a la respuesta:</p>
<p>Supongamos que hemos fijado <span class="math inline">\(l\)</span> y <span class="math inline">\(r = l + L - 1\)</span>, entonces notamos que si deseamos que un subarreglo de mi permutación aporte, necesitamos que exista un subarreglo de tamaño <span class="math inline">\(L\)</span> tal que contenga a <span class="math inline">\(l\)</span> como mínimo y a <span class="math inline">\(r\)</span> como máximo.</p>
<p><strong>Observación 1:</strong> Solamente se puede dar lo anterior cuando el subarreglo contiene todos los elementos en el rango <span class="math inline">\([l, r]\)</span>.</p>
<p><strong>Observación 2:</strong> La cantidad de veces que se puede dar este caso en una permutación fijada es:</p>
<p><span class="math display">\[ (\text{Posiciones posibles}) \cdot (\text{Formas de reordenar los L elementos}) \cdot (\text{Formas de reordenar el resto de elementos}) \]</span></p>
<p>Entonces, notamos que <span class="math inline">\(\text{Posiciones posibles} = n - L + 1\)</span>, <span class="math inline">\(\text{Formas de reordenar los L elementos} = L!\)</span> y <span class="math inline">\(\text{Formas de reordenar el resto de elementos} = (n - L)!\)</span>.</p>
<p>Ahora, esto lo hemos hecho fijando en <span class="math inline">\(L\)</span> y el <span class="math inline">\(l\)</span>, pero fijar ambos valores nos daría una complejidad de <span class="math inline">\(O(n^{2})\)</span>. Entonces notamos que la expresión no depende de <span class="math inline">\(l\)</span>, sino de <span class="math inline">\(L\)</span>, así que la respuesta parcial será multiplicar la cantidad de formas de elegir <span class="math inline">\(l\)</span> a la expresión anterior. La cantidad de formas de elegir <span class="math inline">\(l\)</span> también es <span class="math inline">\((n - L + 1)\)</span>, así que:</p>
<p><span class="math display">\[ aporte(L) = (n - L + 1)^{2} \cdot L! \cdot (n - L)! \]</span></p>
<!-- begin code -->
<div class="collapsed code-title" type="button" data-toggle="collapse" data-target="#codeExample2" aria-expanded="false" aria-controls="collapseTwo">
<!-- title -->
<i class="fas fa-caret-right"></i>
<p class="title">
Código (por racsosabe)
</p>
</div>
<div id="codeExample2" class="collapse">
<pre class="cpp"><code>#include&lt;bits/stdc++.h&gt;
using namespace::std;

const int N = 250000+5;

int n, MOD;
int f[N];

int add(int a, int b, int m = MOD){
    return (a + b) % m;
}

int mul(long long a, long long b, int m = MOD){
    return (a * b) % m;
}

void init(){
    f[0] = 1;
    for(int i = 1; i &lt;= n; i++) f[i] = mul(f[i-1], i);
}

int solve(int L){
    return mul(mul(n - L + 1, n - L + 1), mul(f[L], f[n - L]));
}

int main(){
    scanf(&quot;%d %d&quot;, &amp;n, &amp;MOD);
    init();
    int ans = 0;
    for(int L = 1; L &lt;= n; L++){
        ans = add(ans, solve(L));
    }
    printf(&quot;%d\n&quot;, ans);
    return 0;
}</code></pre>
</div>
<!-- ends code -->
</div>
<div id="c.-distributed-join" class="section level2">
<h2><a href="https://codeforces.com/group/j1UosVRZar/contest/287329/problem/C">C. Distributed Join</a></h2>
<p>Una de las estrategias óptimas en este problema es ubicar un nodo <span class="math inline">\(a\)</span> con la mayor cantidad de filas de información en alguno de los clúster, luego mover toda la información del cluster al que no pertenece <span class="math inline">\(a\)</span> hacia <span class="math inline">\(a\)</span>. Luego de esto basta intentar para el resto de nodos del clúster de <span class="math inline">\(a\)</span> la mejor de dos opciones: Mover toda la información del otro cluster a esa posición o mover la información del nodo actual al <span class="math inline">\(a\)</span>.</p>
<!-- begin code -->
<div class="collapsed code-title" type="button" data-toggle="collapse" data-target="#codeExample3" aria-expanded="false" aria-controls="collapseTwo">
<!-- title -->
<i class="fas fa-caret-right"></i>
<p class="title">
Código (por racsosabe, idea por Fischer)
</p>
</div>
<div id="codeExample3" class="collapse">
<pre class="cpp"><code>#include&lt;bits/stdc++.h&gt;
using namespace::std;

const int N = 100000+5;

typedef long long ll;

int n;
int m;
int a[N];
int b[N];

long long solve(){
    sort(a + 1, a + 1 + n);
    sort(b + 1, b + 1 + m);
    ll sumA = accumulate(a + 1, a + 1 + n, 0LL);
    ll sumB = accumulate(b + 1, b + 1 + m, 0LL);
    ll ansA = sumB, ansB = sumA;
    for(int i = 1; i &lt; n; i++){
        ansA += min(1LL * a[i], sumB);
    }
    for(int i = 1; i &lt; m; i++){
        ansB += min(1LL * b[i], sumA);
    }
    return min(ansA, ansB);
}

int main(){
    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
    for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, a+i);
    for(int i = 1; i &lt;= m; i++) scanf(&quot;%d&quot;, b+i);
    printf(&quot;%lld\n&quot;, solve());
    return 0;
}</code></pre>
</div>
<!-- ends code -->
</div>
<div id="d.-restaurant-tables" class="section level2">
<h2><a href="https://codeforces.com/group/j1UosVRZar/contest/287329/problem/D">D. Restaurant Tables</a></h2>
<p>Para resolver el problema basta con implementar según el enunciado.</p>
<!-- begin code -->
<div class="collapsed code-title" type="button" data-toggle="collapse" data-target="#codeExample4" aria-expanded="false" aria-controls="collapseTwo">
<!-- title -->
<i class="fas fa-caret-right"></i>
<p class="title">
Código (por racsosabe)
</p>
</div>
<div id="codeExample4" class="collapse">
<pre class="cpp"><code>#include&lt;bits/stdc++.h&gt;
using namespace::std;

int n, a, b;

int main(){
    scanf(&quot;%d %d %d&quot;, &amp;n, &amp;a, &amp;b);
    int ans = 0;
    int c = 0;
    for(int i = 1; i &lt;= n; i++){
        int x;
        scanf(&quot;%d&quot;, &amp;x);
        if(x == 1){
            if(a == 0){
                if(b == 0){
                    if(c == 0) ans += 1;
                    else{
                        c -= 1;
                    }
                }
                else{
                    b -= 1;
                    c += 1;
                }
            }
            else a -= 1;
        }
        else{
            if(b == 0) ans += 2;
            else b -= 1;
        }
    }
    printf(&quot;%d\n&quot;, ans);
    return 0;
}</code></pre>
</div>
<!-- ends code -->
</div>
<div id="e.-alice-bob-and-chocolate" class="section level2">
<h2><a href="https://codeforces.com/group/j1UosVRZar/contest/287329/problem/E">E. Alice, Bob and Chocolate</a></h2>
<p>Para resolver este problema bastaba simular usando two pointers y siempre darle prioridad al que coma primero o, si hay empate, a Alice.</p>
<!-- begin code -->
<div class="collapsed code-title" type="button" data-toggle="collapse" data-target="#codeExample5" aria-expanded="false" aria-controls="collapseTwo">
<!-- title -->
<i class="fas fa-caret-right"></i>
<p class="title">
Código (por racsosabe)
</p>
</div>
<div id="codeExample5" class="collapse">
<pre class="cpp"><code>#include&lt;bits/stdc++.h&gt;
using namespace::std;

const int N = 100000+5;

int n;
int a[N];

int main(){
    scanf(&quot;%d&quot;, &amp;n);
    for(int i=1; i&lt;=n; i++){
        scanf(&quot;%d&quot;, a+i);
    }
    int cL = 0, cR = 0;
    int L = 1, R = n;
    int tL = 0, tR = 0;
    while(L &lt;= R){
        if(tL &lt;= tR){
            cL += 1;
            tL += a[L];
            L += 1;
        }
        else{
            cR += 1;
            tR += a[R];
            R -= 1;
        }
    }
    printf(&quot;%d %d\n&quot;, cL, cR);
    return 0;
}</code></pre>
</div>
<!-- ends code -->
</div>
<div id="f.-wet-shark-and-blocks" class="section level2">
<h2><a href="https://codeforces.com/group/j1UosVRZar/contest/287329/problem/F">F. Wet Shark and Blocks</a></h2>
<p>Para resolver este problema basta con modelarlo como un grafo dirigido (posibles multiaristas) de residuos <span class="math inline">\(G = (V, E)\)</span> definido de la siguiente forma:</p>
<p><span class="math display">\[ V = \{0, 1, \ldots, x-1\} \]</span></p>
<p><span class="math display">\[ E = \{(u, v) \text{ existe una vez por cada }a_{i} \text{ tal que }10u + a_{i} \equiv v \mod x\} \]</span></p>
<p>Entonces, lo que se busca sobre este grafo es la cantidad de caminos de longitud <span class="math inline">\(b\)</span> desde el nodo <span class="math inline">\(0\)</span> al nodo <span class="math inline">\(k\)</span>. Esto se puede calcular con exponenciación rápida de matrices, considerando la matriz de adyacencia ponderada definida como:</p>
<p><span class="math display">\[ M_{ij} = \text{Cantidad de aristas }(i, j)\text{ en E} \]</span></p>
<!-- begin code -->
<div class="collapsed code-title" type="button" data-toggle="collapse" data-target="#codeExample6" aria-expanded="false" aria-controls="collapseTwo">
<!-- title -->
<i class="fas fa-caret-right"></i>
<p class="title">
Código (por racsosabe)
</p>
</div>
<div id="codeExample6" class="collapse">
<pre class="cpp"><code>#include&lt;bits/stdc++.h&gt;
using namespace::std;

const int N = 100+5;
const int MOD = 1000000000+7;

int add(int a, int b, int m = MOD){
    return (a + b) % m;
}

int mul(long long a, long long b, int m = MOD){
    return (a * b) % m;
}

int n, b, k, x;
int M[N][N];
int C[N][N];
int R[N][N];
int frec[N];

void multiply(int type){
    for(int i = 0; i &lt; x; i++){
        for(int j = 0; j &lt; x; j++){
            C[i][j] = 0;
            for(int p = 0; p &lt; x; p++){
                if(type == 1){
                    C[i][j] = add(C[i][j], mul(M[i][p], R[p][j]));
                }
                else{
                    C[i][j] = add(C[i][j], mul(M[i][p], M[p][j]));
                }
            }
        }
    }
    for(int i = 0; i &lt; x; i++){
        for(int j = 0; j &lt; x; j++){
            if(type == 1) R[i][j] = C[i][j];
            else M[i][j] = C[i][j];
        }
    }
}

void fastexp(int e){
    while(e &gt; 0){
        if(e &amp; 1) multiply(1);
        multiply(0);
        e &gt;&gt;= 1;
    }
}

int main(){
    scanf(&quot;%d %d %d %d&quot;, &amp;n, &amp;b, &amp;k, &amp;x);
    for(int i = 1; i &lt;= n; i++){
        int d;
        scanf(&quot;%d&quot;, &amp;d);
        frec[d] += 1;
    }
    for(int r1 = 0; r1 &lt; x; r1++){
        for(int d = 1; d &lt; 10; d++){
            int r3 = add(mul(r1, 10, x), d, x);
            M[r1][r3] += frec[d];
        }
    }
    for(int i = 0; i &lt; x; i++){
        for(int j = 0; j &lt; x; j++){
            R[i][j] = i == j;
        }
    }
    fastexp(b);
    printf(&quot;%d\n&quot;, R[0][k]);
    return 0;
}</code></pre>
</div>
<!-- ends code -->
</div>
<div id="g.-multihedgehog" class="section level2">
<h2><a href="https://codeforces.com/group/j1UosVRZar/contest/287329/problem/G">G. Multihedgehog</a></h2>
<p>Para resolver este problema debemos usar una pista que nos da el enunciado: Al iniciar el procedimiento, <strong>se elige un nodo como centro</strong> y desde ahí se desprenden el resto de los hedgehog.</p>
<p><strong>Observación clave:</strong> El centro del hedgehog es el centro del árbol, ya que por la forma de construcción siempre se crean nuevas hojas tomándolo como referencia, así que todas estas están en el mismo nivel.</p>
<p>Gracias a la observación clave nos basta hallar el centro del árbol, con lo que hay dos casos:</p>
<ol style="list-style-type: decimal">
<li><p>Hay un solo centro: Podemos mandar un DFS para verificar que cumpla con la estructura.</p></li>
<li><p>Hay dos centros: No es posible, ya que solo debe haber 1 para que cumpla.</p></li>
</ol>
<!-- begin code -->
<div class="collapsed code-title" type="button" data-toggle="collapse" data-target="#codeExample7" aria-expanded="false" aria-controls="collapseTwo">
<!-- title -->
<i class="fas fa-caret-right"></i>
<p class="title">
Código (por racsosabe)
</p>
</div>
<div id="codeExample7" class="collapse">
<pre class="cpp"><code>#include&lt;bits/stdc++.h&gt;
using namespace::std;

const int N = 100000+5;

int n, k;
int h[N];
int deg[N];
int sum[N];
bool vis[N];
vector&lt;int&gt; G[N];

bool DFS(int u, int depth, int p = -1){
    if(depth == 0) return G[u].size() == 1;
    int deg = 0;
    bool ans = true;
    for(int v : G[u]){
        if(v == p) continue;
        if(!DFS(v, depth - 1, u)) ans = false;
        deg += 1;
    }
    return deg &gt;= 3 and ans;
}

bool solve(){
    vector&lt;int&gt; frontier;
    int cnt = n;
    for(int i = 1; i &lt;= n; i++){
        h[i] = n;
        if(deg[i] == 1){
            deg[i] = 0;
            h[i] = 0;
            vis[i] = true;
            frontier.emplace_back(i);
        }
    }
    while(!frontier.empty() and cnt &gt;= 2){
        vector&lt;int&gt; new_frontier;
        for(auto x : frontier){
            cnt -= 1;
            for(int v : G[x]){
                if(vis[v]) continue;
                deg[v] -= 1;
                if(deg[v] == 1){
                    vis[v] = true;
                    new_frontier.emplace_back(v);
                    deg[v] = 0;
                }
            }
        }
        swap(frontier, new_frontier);
    }
    if(cnt == 0) return false;
    if(frontier.empty()) return false;
    return DFS(frontier.back(), k);
}

int main(){
    scanf(&quot;%d %d&quot;, &amp;n, &amp;k);
    for(int i = 1; i &lt; n; i++){
        int u, v;
        scanf(&quot;%d %d&quot;, &amp;u, &amp;v);
        G[u].emplace_back(v);
        G[v].emplace_back(u);
        deg[v] += 1;
        deg[u] += 1;
    }
    puts(solve()?&quot;Yes&quot;:&quot;No&quot;);
    return 0;
}</code></pre>
</div>
<!-- ends code -->
</div>
<div id="h.-games-with-rectangle" class="section level2">
<h2><a href="https://codeforces.com/group/j1UosVRZar/contest/287329/problem/H">H. Games with Rectangle</a></h2>
<p>Para resolver este problema bastaba notar que la elección de las dos dimensiones es independiente, así que podemos hallar la cantidad de formas de realizar <span class="math inline">\(k\)</span> movimientos sobre una base de tamaño <span class="math inline">\(n\)</span> y la cantidad de formas con una base <span class="math inline">\(m\)</span> y multiplicar dicho valor.</p>
<p>Entonces, ¿Cómo hallamos la cantidad de formas de realizar <span class="math inline">\(k\)</span> movimientos sobre una base de tamaño <span class="math inline">\(n\)</span>? Podemos definir la siguiente función:</p>
<p><span class="math display">\[ memo[k][n] = \text{Cantidad de formas de realizar k movimientos sobre una base de tamaño n} \]</span></p>
<p>Ahora, podemos fijar el primer movimiento para obtener la base nueva y contar su aporte:</p>
<p><span class="math display">\[ memo[k][n] = \sum\limits_{1 \leq l \leq n - 2}Aporte(n, l, k) \]</span></p>
<p>Sin embargo, notamos que la función <span class="math inline">\(Aporte(n, l, k)\)</span> depende de la cantidad de posiciones que pueda tomar <span class="math inline">\(l\)</span> sobre la base <span class="math inline">\(n\)</span> cumpliendo las reglas y la cantidad de formas de realizar <span class="math inline">\(k - 1\)</span> movimientos con una base de tamaño <span class="math inline">\(l\)</span>:</p>
<p><span class="math display">\[ Aporte(n, l, k) = memo[k-1][l] \cdot (n - 1 - l) \]</span></p>
<p>Entonces si reemplazamos:</p>
<p><span class="math display">\[ memo[k][n] = \sum\limits_{1 \leq l \leq n - 2}memo[k-1][l] \cdot (n - 1 - l) \]</span></p>
<p><span class="math display">\[ memo[k][n] = (n - 1)\sum\limits_{1 \leq l \leq n - 2}memo[k-1][l] - \sum\limits_{1 \leq l \leq n - 2}l\cdot memo[k-1][l] \]</span></p>
<p>Ahora, si preprocesamos en <span class="math inline">\(O(n)\)</span> los resultados de la suma de <span class="math inline">\(\sum\limits_{1 \leq l \leq n - 2}memo[k-1][l]\)</span> y <span class="math inline">\(\sum\limits_{1 \leq l \leq n - 2}l\cdot memo[k-1][l]\)</span> por separado en arreglos <span class="math inline">\(suma[k-1][n-2]\)</span> y <span class="math inline">\(sump[k-1][n-2]\)</span> respectivamente, tendremos:</p>
<p><span class="math display">\[ memo[k][n] = (n-1)\cdot suma[k-1][n-2] - sump[k-1][n-2] \]</span></p>
<p>Y así podremos resolver el problema en <span class="math inline">\(O(n^{2})\)</span>.</p>
<!-- begin code -->
<div class="collapsed code-title" type="button" data-toggle="collapse" data-target="#codeExample8" aria-expanded="false" aria-controls="collapseTwo">
<!-- title -->
<i class="fas fa-caret-right"></i>
<p class="title">
Código (por racsosabe)
</p>
</div>
<div id="codeExample8" class="collapse">
<pre class="cpp"><code>#include&lt;bits/stdc++.h&gt;
using namespace::std;

const int N = 1000+5;
const int MOD = 1000000000+7;

int add(int a, int b, int m = MOD){
    return (a + b) % m;
}

int mul(long long a, long long b, int m = MOD){
    return (a * b) % m;
}

int n, m, k;
int memo[N][N];
int suma[N][N];
int sump[N][N];

void get(int r, int limit){
    for(int i = 1; i &lt;= limit; i++){
        suma[r][i] = add(suma[r][i-1], memo[r][i]);
        sump[r][i] = add(sump[r][i-1], mul(i, memo[r][i]));
    }
}

void init(int limit){
    for(int i = 1; i &lt;= limit; i++) memo[0][i] = 1;
    for(int i = 1; i &lt;= k; i++){
        get(i - 1, limit);
        for(int l = 1; l &lt;= limit; l++){
            memo[i][l] = add(mul(l - 1, suma[i-1][l-2]), MOD - sump[i-1][l-2]);
        }
    }
}

int main(){
    scanf(&quot;%d %d %d&quot;, &amp;n, &amp;m, &amp;k);
    init(max(n, m));
    printf(&quot;%d\n&quot;, mul(memo[k][n], memo[k][m]));
    return 0;
}</code></pre>
</div>
<!-- ends code -->
</div>
<div id="i.-morning-run" class="section level2">
<h2><a href="https://codeforces.com/group/j1UosVRZar/contest/287329/problem/I">I. Morning run</a></h2>
<p>Nos piden hallar el valor esperado de los encuentros entre los corredores. ¿Cómo hacer eso? Como un primer paso, el valor esperado es lineal, así que podemos partir los problemas iniciales en diferentes: hallar el valor esperado de encuentros entre un par de corredores fijo. Resolveremos estas particiones para obtener el resultado total. Para ello, necesitamos hacer algunas observaciones:</p>
<ol style="list-style-type: decimal">
<li><p>Sea <span class="math inline">\(x\)</span> la distancia entre dos corredores y supongamos que corran en direcciones opuestas por un tiempo infinito (la probabilidad de que esto suceda obviamente es igual a <span class="math inline">\(0.5\cdot 0.5 = 0.25\)</span>). Entonces, su primer encuentro sucederá en el tiempo <span class="math inline">\(\frac{x}{2}\)</span>, la siguiente — <span class="math inline">\(\frac{x}{2} + \frac{l}{2}\)</span>, la siguiente — <span class="math inline">\(\frac{x}{2} + \frac{l}{2} + \frac{l}{2}\)</span>, etc.</p></li>
<li><p>Asumamos que cada carrera duró <span class="math inline">\(l\)</span> unidades de tiempo; entonces si dos corredores se encontraron, se encontrarán exactamente 2 veces. La probabilidad del encuentro es igual a <span class="math inline">\(0.5\)</span>, dado que ellos corren hacia la misma dirección en 2 casos y en direcciones opuestas en 2 casos.</p></li>
</ol>
<p>Construiremos nuestra solución basándonos en estas dos observaciones. Como primer paso representaremos <span class="math inline">\(t\)</span> como <span class="math inline">\(t = k\cdot l + p\)</span>, donde <span class="math inline">\(0 \leq p &lt; l\)</span>. Entonces, cada corredor correrá <span class="math inline">\(k\)</span> vueltas completas. ¿Qué significa esto? Dado que tenemos <span class="math inline">\(\frac{n(n-1)}{2}\)</span> pares de corredores, entonces en esas <span class="math inline">\(k\)</span> vueltas cada par tendrá <span class="math inline">\(2k\)</span> encuentros con probabilidad igual a <span class="math inline">\(0.5\)</span>. De esta manera, necesitamos agregar <span class="math inline">\(2k\cdot \frac{n(n-1)}{2} \cdot 0.5 = \frac{kn(n-1)}{2}\)</span> a nuestra respuesta.</p>
<p>Ahora necesitamos tomar en cuenta los <span class="math inline">\(p\)</span> segundos de carrera. Asumamos que la distancia entre dos corredores es <span class="math inline">\(x\)</span> y ellos corren en direcciones opuestas. Entonces, ellos se encontrarán si <span class="math inline">\(\frac{x}{2} \leq t\)</span>, o su equivalente <span class="math inline">\(x  \leq 2t\)</span>. Ellos se encontrarán una segunda vez si <span class="math inline">\(\frac{x}{2} + \frac{l}{2} \leq t\)</span>, o su equivalente <span class="math inline">\(x \leq 2t - l\)</span>. No se pueden encontrar más de 2 veces, debido a que <span class="math inline">\(p &lt; l\)</span>.</p>
<p>Fijemos uno de los corredores (sea <span class="math inline">\(i\)</span>), entonces podemos usar binary search para encontrar todos los demás corredores a una distancia no mayor a <span class="math inline">\(x\)</span> del que hemos fijado. Sea <span class="math inline">\(x = 2t\)</span>, entonces la cantidad de corredores a una distancia no mayor a <span class="math inline">\(x\)</span> expresa la cantidad de corredores que se encuentran con el corredor <span class="math inline">\(i\)</span> al menos una vez. Si <span class="math inline">\(x = 2t - l\)</span>, encontraremos la cantidad de corredores que se encuentran con <span class="math inline">\(i\)</span> exactamente dos veces. Multiplicaremos estos valores por <span class="math inline">\(0.25\)</span> — la probabilidad del encuentro, y los agregaremos a la respuesta.</p>
<p>La complejidad de esta solución es <span class="math inline">\(O(n\log{n})\)</span>. Podemos reducirla usando two pointers.</p>
<!-- begin code -->
<div class="collapsed code-title" type="button" data-toggle="collapse" data-target="#codeExample9" aria-expanded="false" aria-controls="collapseTwo">
<!-- title -->
<i class="fas fa-caret-right"></i>
<p class="title">
Código (por Fischer)
</p>
</div>
<div id="codeExample9" class="collapse">
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 1e6 + 10;
 
int main() {
    int n, l, t;
    scanf(&quot;%d %d %d&quot;, &amp;n, &amp;l, &amp;t);
    vector&lt;int&gt; a(n);
    for (auto&amp; x : a) scanf(&quot;%d&quot;, &amp;x);
    t *= 2;
    double ans = (t/l)*1.d*(n*1ll*(n-1));
    int r = t % l;
    for (int i = 0; i &lt; n; ++i) {
        a.emplace_back(a[i] + l);
    }
    for (int i = n-1; i &gt;= 0; --i) {
        int lo = 0, hi = 2 * n - 1;
        while (lo &lt; hi) {
            int mid = lo + (hi - lo + 1) / 2;
            if (a[mid] &lt;= a[i] + r) lo = mid;
            else hi = mid - 1;
        }
        ans += lo - i;
    }
    printf(&quot;%.8lf\n&quot;, ans / 4);
    return 0;
}</code></pre>
</div>
<!-- ends code -->
</div>
<div id="j.-photographer" class="section level2">
<h2><a href="https://codeforces.com/group/j1UosVRZar/contest/287329/problem/J">J. Photographer</a></h2>
<p>Para resolver este problema bastaba notar que el costo de memoria por cada cliente era fijo, así que podíamos ordenar los clientes por costo ascendente e ir tomando pedidos hasta que ya no nos alcance la memoria.</p>
<!-- begin code -->
<div class="collapsed code-title" type="button" data-toggle="collapse" data-target="#codeExample10" aria-expanded="false" aria-controls="collapseTwo">
<!-- title -->
<i class="fas fa-caret-right"></i>
<p class="title">
Código (por racsosabe)
</p>
</div>
<div id="codeExample10" class="collapse">
<pre class="cpp"><code>#include&lt;bits/stdc++.h&gt;
using namespace::std;

const int N = 100000+5;

int n, d;
int a, b;
long long c[N];

int main(){
    scanf(&quot;%d %d&quot;, &amp;n, &amp;d);
    scanf(&quot;%d %d&quot;, &amp;a, &amp;b);
    for(int i = 1; i &lt;= n; i++){
        int x, y;
        scanf(&quot;%d %d&quot;, &amp;x, &amp;y);
        c[i] = 1LL * x * a + 1LL * y * b;
    }
    vector&lt;int&gt; p(n);
    iota(p.begin(), p.end(), 1);
    sort(p.begin(), p.end(), [&amp;] (int i, int j){
        return c[i] &lt; c[j];
    });
    vector&lt;int&gt; ans;
    for(int i : p){
        if(d &gt;= c[i]){
            ans.emplace_back(i);
            d -= c[i];
        }
    }
    printf(&quot;%d\n&quot;, (int)ans.size());
    for(int i = 0; i &lt; ans.size(); i++){
        printf(&quot;%d%c&quot;, ans[i], &quot; \n&quot;[i + 1 == ans.size()]);
    }
    return 0;
}</code></pre>
</div>
<!-- ends code -->
</div>
<div id="k.-new-year-and-arbitrary-arrangement" class="section level2">
<h2><a href="https://codeforces.com/group/j1UosVRZar/contest/287329/problem/K">K. New Year and Arbitrary Arrangement</a></h2>
<p>El principal truco de este problema es que la secuencia podría volverse arbitrariamente larga, pero deseamos una respuesta exacta. En particular, debemos pensar cómo reducir este problema a notar qué información de un prefijo de la secuencia que hemos construido necesitamos mantener para simular nuestro algoritmo correctamente. Esto sugiere un enfoque con programación dinámica.</p>
<p>Para nuestro estado de DP, necesitamos llevar cierta información de nuestro prefijo. En primer lugar, el candidato más obvio es la cantidad de veces que ocurre la cadena ‘ab’ en el prefijo (de esa manera podremos saber cuándo deternernos). Sin embargo, usar esto no es suficiente, ya que no podremos diferenciar secuencias como ‘ab’ y ‘abaaaa’. Entonces, esto sugiere que también debemos llevar la cuenta de la cantidad de ’a’s.</p>
<p>Sea <span class="math inline">\(dp[i][j]\)</span> la respuesta esperada dado que hay <span class="math inline">\(i\)</span> subsecuencias de la forma ‘a’ en el prefijo y <span class="math inline">\(j\)</span> subsecuencias de la forma ‘ab’.</p>
<p>Entonces, tenemos algo como <span class="math inline">\(dp[i][j] = (p_{a} \cdot dp[i + 1][j] + p_{b} \cdot dp[i][i + j]) / (p_{a} + p_{b})\)</span>. El primer término de la suma viene de agregar otra ‘a’ a nuestra secuencia, mientras que el segundo viene de agregar una ‘b’. También tenemos que <span class="math inline">\(dp[i][j] = j\)</span> si <span class="math inline">\(j \geq k\)</span> como un caso base. La respuesta debería ser <span class="math inline">\(dp[0][0]\)</span>.</p>
<p>Sin embargo, si ejecutamos esto así nomas, notaremos que aún hay algunos problemas. Uno es que <span class="math inline">\(i\)</span> puede volverse arbitrariamente grande a medida que agregamos ‘a’ indefinidamente. En vez de eso, podemos modificar nuestro caso base a cuando se dé que <span class="math inline">\(i + j \geq k\)</span>. En este caso, la siguiente vez que pongamos una ‘b’, nos detendremos, así que podemos hallar una forma cerrada de este escenario. El segundo es que cualquier cantidad de ‘b’s que aparezcan antes de la primera ’a’ puede ser esencialmente ignorada. Para solucionar esto, podemos ajustar nuestra respuesta a <span class="math inline">\(dp[1][0]\)</span>.</p>
<!-- begin code -->
<div class="collapsed code-title" type="button" data-toggle="collapse" data-target="#codeExample11" aria-expanded="false" aria-controls="collapseTwo">
<!-- title -->
<i class="fas fa-caret-right"></i>
<p class="title">
Código (por Fischer)
</p>
</div>
<div id="codeExample11" class="collapse">
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 1005;
const int mod = 1e9 + 7;
 
int add(int a, int b) {
    return (a+b)%mod;
}
 
int mul(long long a, long long b) {
    return a*b%mod;
}
 
int ex(int a, int b) {
    int r = 1;
    while (b &gt; 0) {
        if (b&amp;1) r = mul(r, a); 
        a = mul(a, a);
        b &gt;&gt;= 1;
    }
    return r;
}
 
int memo[maxn][maxn];
 
int main() {
    int k, a, b;
    cin &gt;&gt; k &gt;&gt; a &gt;&gt; b;
    int p = mul(a, ex(a+b, mod-2));
    int q = mul(b, ex(a+b, mod-2));
    memo[0][0] = 1;
    int ans = 0;
    for (int i = 0; i &lt; k; ++i) {
        for (int j = 0; j &lt; k; ++j) {
            if (i == 0) {
                memo[i+1][j] = add(memo[i+1][j], memo[i][j]);
                continue;
            }
            memo[i+1][j] = add(memo[i+1][j], mul(p, memo[i][j]));
            if (i + j &lt; k) {
                memo[i][i+j] = add(memo[i][i+j], mul(q, memo[i][j]));
            } else {
                ans = add(ans, mul(i + j, mul(q, memo[i][j])));
            }
        }
    }
    for (int i = 0; i &lt; k; ++i) {
        ans = add(ans, mul(i+k+mul(p, ex(q, mod-2)), memo[k][i]));
    }
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}</code></pre>
</div>
<!-- ends code -->
</div>
<div id="l.-relay-race" class="section level2">
<h2><a href="https://codeforces.com/group/j1UosVRZar/contest/287329/problem/L">L. Relay Race</a></h2>
<p>Para resolver este problema bastaba reducir la respuesta a hallar dos caminos de <span class="math inline">\((0, 0)\)</span> a <span class="math inline">\((n-1, n-1)\)</span> tal que contemos una sola vez cada elemento en la suma.</p>
<p>Entonces, podemos plantear el tener 2 caminos que actualmente estén en las posiciones <span class="math inline">\((x_{1}, y_{1})\)</span> y <span class="math inline">\((x_{2}, y_{2})\)</span> y que se cumpla que <span class="math inline">\((x_{1}, y_{1}) \leq (x_{2}, y_{2})\)</span> por comparación lexicográfica (de manera que los caminos no se crucen estrictamente pero si puedan encontrarse en puntos en común).</p>
<p>Esto nos da una solución <span class="math inline">\(O(n^{4})\)</span> con <span class="math inline">\(O(n^{4})\)</span> de memoria, lo cual no nos basta. Sin embargo, ya que nuestro camino es monótono, tendremos que <span class="math inline">\(x + y = pasos\)</span> en todo momento, así que si tenemos una de las coordenadas y el número de pasos realizados, podemos deducir la coordenada faltante.</p>
<p>Una opción sería tener un DP con parámetros <span class="math inline">\((pasos, x_{1}, x_{2})\)</span>, pero esto requeriría <span class="math inline">\((2 (n-1)\cdot(n-1)\cdot(n-1))\)</span> de memoria, lo cual puede darnos problemas con el ML, así que llevaremos los parámetros <span class="math inline">\((x_{1}, y_{1}, x_{2})\)</span>, ya que podemos deducir <span class="math inline">\(pasos = x_{1} + y_{1}\)</span>.</p>
<p>Ya que tenemos nuestro DP definido, podemos simular las elecciones y maximizar la suma de las celdas visitadas sin contar doble.</p>
<!-- begin code -->
<div class="collapsed code-title" type="button" data-toggle="collapse" data-target="#codeExample12" aria-expanded="false" aria-controls="collapseTwo">
<!-- title -->
<i class="fas fa-caret-right"></i>
<p class="title">
Código (por racsosabe)
</p>
</div>
<div id="codeExample12" class="collapse">
<pre class="cpp"><code>#include&lt;bits/stdc++.h&gt;
using namespace::std;

const int N = 300+5;
const int inf = 1&lt;&lt;29;

int n;
int a[N][N];
bool vis[N][N][N];
int memo[N][N][N];
int dx[] = {1, 0};
int dy[] = {0, 1};

bool validPos(int x, int y){
    return x &gt;= 0 and y &gt;= 0 and x &lt; n and y &lt; n;
}

int DP(int x1, int y1, int x2){
    int diag = x1 + y1;
    int y2 = diag - x2;
    if(diag == 2 * (n - 1)) return a[x1][y1];
    if(vis[x1][y1][x2]) return memo[x1][y1][x2];
    int ans = -inf;
    for(int i = 0; i &lt; 2; i++){
        int vx1 = x1 + dx[i];
        int vy1 = y1 + dy[i];
        if(!validPos(vx1, vy1)) continue;
        for(int j = 0; j &lt; 2; j++){
            int vx2 = x2 + dx[j];
            int vy2 = y2 + dy[j];
            if(!validPos(vx2, vy2)) continue;
            if(make_pair(vx1, vy1) &lt;= make_pair(vx2, vy2)){
                int cur = (x1 == x2 and y1 == y2? a[x1][y1] : a[x1][y1] + a[x2][y2]) + DP(vx1, vy1, vx2);
                if(ans &lt; cur) ans = cur;
            }
        }
    }
    vis[x1][y1][x2] = true;
    return memo[x1][y1][x2] = ans;
}

int main(){
    scanf(&quot;%d&quot;, &amp;n);
    for(int i = 0; i &lt; n; i++){
        for(int j = 0; j &lt; n; j++){
            scanf(&quot;%d&quot;, &amp;a[i][j]);
        }
    }
    printf(&quot;%d\n&quot;, DP(0,0,0));
    return 0;
}</code></pre>
</div>
<!-- ends code -->
</div>




</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
